import algosdk from 'algosdk'
import type { Request, Response } from 'express'
import express from 'express'
import { v4 as uuidv4 } from 'uuid'

import { env } from '../../env'
import users from '../../mock/users.db.json' assert { type: 'json' }

interface AuthMessage {
  /** The domain name of the Verifier */
  domain: string
  /** Algorand account to authenticate with, encoded as a 32-bytes Algorand address */
  authAcc: string
  /** Unique random challenge of at least 15 characters and generated by the Verifier */
  challenge: string
  /** Algorand network identifier, encoded as a 32-bytes genesis hash of the network */
  chainId: string
  /** Optional, description of the Verifier */
  desc?: string
  /** Optional, metadata */
  meta?: string
}

enum AlgorandGenesisHash {
  MainNet = 'wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=',
  TestNet = 'SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=',
  BetaNet = 'mFgazF+2uRS1tMiL9dsj01hJGySEmPN28B/TjjvpVW0='
}

const v1 = express.Router()

const prefix = 'arc0031'

v1.post('/signin/request', (req: Request<never, { authAcc: string, chain: string }, never, never>, res: Response) => {
  const {
    authAcc,
    chain
  } = req.body

  if (!chain || !(chain in AlgorandGenesisHash)) {
    return res.sendStatus(400)
  }

  if (!authAcc || !algosdk.isValidAddress(authAcc)) {
    return res.sendStatus(400)
  }

  const user = users.find(user => user.authAcc === authAcc)
  if (!user) {
    return res.sendStatus(401)
  }

  const validChainId = chain as keyof typeof AlgorandGenesisHash
  const genesisHashValue = AlgorandGenesisHash[validChainId]

  const challenge = uuidv4()

  const authMessage: AuthMessage = {
    domain: env.SERVICE_NAME,
    authAcc,
    challenge,
    chainId: genesisHashValue,
    desc: env.SERVICE_DESCRIPTION
  }
  user.challenge = challenge
  user.chainId = genesisHashValue

  const message = prefix + JSON.stringify(authMessage)

  return res.send(message)
})

// eslint-disable-next-line require-await
v1.post('/signin/verify', async (req: Request<never, { authAcc: string, signedMessageBase64: string }, never, never>, res: Response) => {
  const {
    authAcc,
    signedMessageBase64
  } = req.body
  try {
    if (!authAcc || !algosdk.isValidAddress(authAcc) || !signedMessageBase64) {
      return res.sendStatus(400)
    }
    const user = users.find(user => user.authAcc === authAcc)
    if (user) {
      const authMessage: AuthMessage = {
        domain: env.SERVICE_NAME,
        authAcc,
        challenge: user.challenge,
        chainId: user.chainId,
        desc: env.SERVICE_DESCRIPTION
      }
      const encodedAuthMessage = prefix + JSON.stringify(authMessage)
      // Convert the message string to bytes
      const messageBytes = Buffer.from(encodedAuthMessage, 'utf-8')
      const signedMessageBytes = Buffer.from(signedMessageBase64, 'base64')

      if (algosdk.verifyBytes(messageBytes, signedMessageBytes, authAcc)) {
        const session = { authAcc, accessToken: uuidv4() }

        return res.status(200).send(session)
      }
    }
  } catch (error) {
    return res.sendStatus(400)
  }

  return res.sendStatus(401)
})

export default v1
