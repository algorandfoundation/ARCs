#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 8
    bytecblock "asset_id" "burned" "locked" "generic"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/circulating_supply/contract.py:24-25
    // # Global State
    // self.asset_id = UInt64()
    bytec_0 // "asset_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/circulating_supply/contract.py:27
    // Address(), key=cfg.NOT_CIRCULATING_LABEL_1
    bytec_1 // "burned"
    global ZeroAddress
    // smart_contracts/circulating_supply/contract.py:26-28
    // self.not_circulating_label_1 = GlobalState(
    //     Address(), key=cfg.NOT_CIRCULATING_LABEL_1
    // )
    app_global_put
    // smart_contracts/circulating_supply/contract.py:30
    // Address(), key=cfg.NOT_CIRCULATING_LABEL_2
    bytec_2 // "locked"
    global ZeroAddress
    // smart_contracts/circulating_supply/contract.py:29-31
    // self.not_circulating_label_2 = GlobalState(
    //     Address(), key=cfg.NOT_CIRCULATING_LABEL_2
    // )
    app_global_put
    // smart_contracts/circulating_supply/contract.py:33
    // Address(), key=cfg.NOT_CIRCULATING_LABEL_3
    bytec_3 // "generic"
    global ZeroAddress
    // smart_contracts/circulating_supply/contract.py:32-34
    // self.not_circulating_label_3 = GlobalState(
    //     Address(), key=cfg.NOT_CIRCULATING_LABEL_3
    // )
    app_global_put

main_after_if_else@2:
    // smart_contracts/circulating_supply/contract.py:20
    // class CirculatingSupply(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@12
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x709b80a8 0x0b62c728 0x5cc2c535 // method "set_asset(uint64)void", method "set_not_circulating_address(address,string)void", method "arc62_get_circulating_supply(uint64)uint64"
    txna ApplicationArgs 0
    match set_asset set_not_circulating_address arc62_get_circulating_supply
    err

main___algopy_default_create@12:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts.circulating_supply.contract.CirculatingSupply.set_asset[routing]() -> void:
set_asset:
    // smart_contracts/circulating_supply/contract.py:36
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/circulating_supply/contract.py:45-46
    // # Preconditions
    // assert Txn.sender == asset.manager and not self.asset_id, err.UNAUTHORIZED
    txn Sender
    swap
    asset_params_get AssetManager
    assert // asset exists
    ==
    bz set_asset_bool_false@4
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    bnz set_asset_bool_false@4
    intc_1 // 1

set_asset_bool_merge@5:
    // smart_contracts/circulating_supply/contract.py:45-46
    // # Preconditions
    // assert Txn.sender == asset.manager and not self.asset_id, err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/circulating_supply/contract.py:47-48
    // # Effects
    // self.asset_id = asset_id
    bytec_0 // "asset_id"
    dig 1
    app_global_put
    // smart_contracts/circulating_supply/contract.py:36
    // @abimethod()
    intc_1 // 1
    return

set_asset_bool_false@4:
    intc_0 // 0
    b set_asset_bool_merge@5


// smart_contracts.circulating_supply.contract.CirculatingSupply.set_not_circulating_address[routing]() -> void:
set_not_circulating_address:
    // smart_contracts/circulating_supply/contract.py:50
    // @abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/circulating_supply/contract.py:59
    // asset = Asset(self.asset_id)
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/circulating_supply/contract.py:60-61
    // # Preconditions
    // assert Txn.sender == asset.manager, err.UNAUTHORIZED
    txn Sender
    dig 1
    asset_params_get AssetManager
    assert // asset exists
    ==
    assert // Unauthorized
    // smart_contracts/circulating_supply/contract.py:62
    // assert Account(address.bytes).is_opted_in(asset), err.NOT_OPTED_IN
    intc_2 // 32
    uncover 3
    ==
    assert // Address length is 32 bytes
    uncover 2
    swap
    asset_holding_get AssetBalance
    bury 1
    assert // Not Opted-In
    // smart_contracts/circulating_supply/contract.py:65
    // case cfg.NOT_CIRCULATING_LABEL_1:
    bytec_1 // "burned"
    // smart_contracts/circulating_supply/contract.py:67
    // case cfg.NOT_CIRCULATING_LABEL_2:
    bytec_2 // "locked"
    // smart_contracts/circulating_supply/contract.py:69
    // case cfg.NOT_CIRCULATING_LABEL_3:
    bytec_3 // "generic"
    // smart_contracts/circulating_supply/contract.py:63-72
    // # Effects
    // match label:
    //     case cfg.NOT_CIRCULATING_LABEL_1:
    //         self.not_circulating_label_1.value = address
    //     case cfg.NOT_CIRCULATING_LABEL_2:
    //         self.not_circulating_label_2.value = address
    //     case cfg.NOT_CIRCULATING_LABEL_3:
    //         self.not_circulating_label_3.value = address
    //     case _:
    //         assert False, err.INVALID_LABEL
    uncover 3
    match set_not_circulating_address_switch_case_0@2 set_not_circulating_address_switch_case_1@3 set_not_circulating_address_switch_case_2@4
    // smart_contracts/circulating_supply/contract.py:72
    // assert False, err.INVALID_LABEL
    err // Invalid Label

set_not_circulating_address_switch_case_2@4:
    // smart_contracts/circulating_supply/contract.py:70
    // self.not_circulating_label_3.value = address
    bytec_3 // "generic"
    dig 1
    app_global_put

set_not_circulating_address_switch_case_next@6:
    // smart_contracts/circulating_supply/contract.py:50
    // @abimethod()
    intc_1 // 1
    return

set_not_circulating_address_switch_case_1@3:
    // smart_contracts/circulating_supply/contract.py:68
    // self.not_circulating_label_2.value = address
    bytec_2 // "locked"
    dig 1
    app_global_put
    b set_not_circulating_address_switch_case_next@6

set_not_circulating_address_switch_case_0@2:
    // smart_contracts/circulating_supply/contract.py:66
    // self.not_circulating_label_1.value = address
    bytec_1 // "burned"
    dig 1
    app_global_put
    b set_not_circulating_address_switch_case_next@6


// smart_contracts.circulating_supply.contract.CirculatingSupply.arc62_get_circulating_supply[routing]() -> void:
arc62_get_circulating_supply:
    pushbytes ""
    dupn 2
    // smart_contracts/circulating_supply/contract.py:74
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/circulating_supply/contract.py:86
    // not_circulating_1 = Account(self.not_circulating_label_1.value.bytes)
    intc_0 // 0
    bytec_1 // "burned"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check self.not_circulating_label_1 exists
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/circulating_supply/contract.py:87
    // not_circulating_2 = Account(self.not_circulating_label_2.value.bytes)
    intc_0 // 0
    bytec_2 // "locked"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check self.not_circulating_label_2 exists
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/circulating_supply/contract.py:88
    // not_circulating_3 = Account(self.not_circulating_label_3.value.bytes)
    intc_0 // 0
    bytec_3 // "generic"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check self.not_circulating_label_3 exists
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/circulating_supply/contract.py:89-90
    // # Preconditions
    // assert asset_id == self.asset_id, err.INVALID_ASSET_ID
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    dig 1
    ==
    assert // Invalid ASA ID
    // smart_contracts/circulating_supply/contract.py:94
    // if asset.reserve == Global.zero_address
    asset_params_get AssetReserve
    assert // asset exists
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:94-95
    // if asset.reserve == Global.zero_address
    // or not asset.reserve.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@3
    // smart_contracts/circulating_supply/contract.py:95
    // or not asset.reserve.is_opted_in(asset)
    dig 3
    dup
    asset_params_get AssetReserve
    assert // asset exists
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@4

arc62_get_circulating_supply_ternary_true@3:
    // smart_contracts/circulating_supply/contract.py:93
    // UInt64(0)
    intc_0 // 0
    bury 5

arc62_get_circulating_supply_ternary_merge@5:
    // smart_contracts/circulating_supply/contract.py:100
    // if not_circulating_1 == Global.zero_address
    dig 2
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:100-101
    // if not_circulating_1 == Global.zero_address
    // or not not_circulating_1.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@7
    // smart_contracts/circulating_supply/contract.py:101
    // or not not_circulating_1.is_opted_in(asset)
    dig 2
    dig 4
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@8

arc62_get_circulating_supply_ternary_true@7:
    // smart_contracts/circulating_supply/contract.py:99
    // UInt64(0)
    intc_0 // 0
    bury 7

arc62_get_circulating_supply_ternary_merge@9:
    // smart_contracts/circulating_supply/contract.py:106
    // if not_circulating_2 == Global.zero_address
    dig 1
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:106-107
    // if not_circulating_2 == Global.zero_address
    // or not not_circulating_2.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@11
    // smart_contracts/circulating_supply/contract.py:107
    // or not not_circulating_2.is_opted_in(asset)
    dig 1
    dig 4
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@12

arc62_get_circulating_supply_ternary_true@11:
    // smart_contracts/circulating_supply/contract.py:105
    // UInt64(0)
    intc_0 // 0
    bury 6

arc62_get_circulating_supply_ternary_merge@13:
    // smart_contracts/circulating_supply/contract.py:112
    // if not_circulating_3 == Global.zero_address
    dup
    global ZeroAddress
    ==
    // smart_contracts/circulating_supply/contract.py:112-113
    // if not_circulating_3 == Global.zero_address
    // or not not_circulating_3.is_opted_in(asset)
    bnz arc62_get_circulating_supply_ternary_true@15
    // smart_contracts/circulating_supply/contract.py:113
    // or not not_circulating_3.is_opted_in(asset)
    dup
    dig 4
    asset_holding_get AssetBalance
    bury 1
    bnz arc62_get_circulating_supply_ternary_false@16

arc62_get_circulating_supply_ternary_true@15:
    // smart_contracts/circulating_supply/contract.py:111
    // UInt64(0)
    intc_0 // 0

arc62_get_circulating_supply_ternary_merge@17:
    // smart_contracts/circulating_supply/contract.py:117
    // asset.total
    dig 4
    asset_params_get AssetTotal
    assert // asset exists
    // smart_contracts/circulating_supply/contract.py:117-118
    // asset.total
    // - reserve_balance
    dig 6
    -
    // smart_contracts/circulating_supply/contract.py:117-119
    // asset.total
    // - reserve_balance
    // - not_circulating_balance_1
    dig 8
    -
    // smart_contracts/circulating_supply/contract.py:117-120
    // asset.total
    // - reserve_balance
    // - not_circulating_balance_1
    // - not_circulating_balance_2
    dig 7
    -
    // smart_contracts/circulating_supply/contract.py:117-121
    // asset.total
    // - reserve_balance
    // - not_circulating_balance_1
    // - not_circulating_balance_2
    // - not_circulating_balance_3
    swap
    -
    // smart_contracts/circulating_supply/contract.py:74
    // @abimethod(readonly=True)
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

arc62_get_circulating_supply_ternary_false@16:
    // smart_contracts/circulating_supply/contract.py:114
    // else asset.balance(not_circulating_3)
    dup
    dig 4
    asset_holding_get AssetBalance
    assert // account opted into asset
    b arc62_get_circulating_supply_ternary_merge@17

arc62_get_circulating_supply_ternary_false@12:
    // smart_contracts/circulating_supply/contract.py:108
    // else asset.balance(not_circulating_2)
    dig 1
    dig 4
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 6
    b arc62_get_circulating_supply_ternary_merge@13

arc62_get_circulating_supply_ternary_false@8:
    // smart_contracts/circulating_supply/contract.py:102
    // else asset.balance(not_circulating_1)
    dig 2
    dig 4
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 7
    b arc62_get_circulating_supply_ternary_merge@9

arc62_get_circulating_supply_ternary_false@4:
    // smart_contracts/circulating_supply/contract.py:96
    // else asset.balance(asset.reserve)
    dig 3
    dup
    asset_params_get AssetReserve
    assert // asset exists
    swap
    asset_holding_get AssetBalance
    assert // account opted into asset
    bury 5
    b arc62_get_circulating_supply_ternary_merge@5
