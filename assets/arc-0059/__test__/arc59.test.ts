import { describe, test, expect, beforeAll, beforeEach } from '@jest/globals';
import { algorandFixture } from '@algorandfoundation/algokit-utils/testing';
import * as algokit from '@algorandfoundation/algokit-utils';
import algosdk from 'algosdk';
import { Arc59Factory, Arc59Client } from '../contracts/clients/Arc59Client';

const fixture = algorandFixture();
algokit.Config.configure({
  populateAppCallResources: true,
  // eslint-disable-next-line no-console
  logger: { error: () => console.error, debug: () => {}, warn: console.warn, info: () => {}, verbose: () => {} },
});

/**
 * Send an asset to a receiver using the ARC59 router
 *
 * @param appClient The ARC59 client generated by algokit
 * @param assetId The ID of the asset to send
 * @param sender The address of the sender
 * @param receiver The address of the receiver
 * @param algorand The AlgorandClient instance to use to send transactions
 */
async function arc59SendAsset(
  appClient: Arc59Client,
  assetId: bigint,
  sender: algosdk.Address,
  receiver: algosdk.Address,
  algorand: algokit.AlgorandClient
) {
  // Get the address of the ARC59 router
  const arc59RouterAddress = appClient.appAddress;

  // Call arc59GetSendAssetInfo to get the following:
  // itxns - The number of transactions needed to send the asset
  // mbr - The minimum balance that must be sent to the router
  // routerOptedIn - Whether the router has opted in to the asset
  // receiverOptedIn - Whether the receiver has opted in to the asset
  const [itxns, mbr, routerOptedIn, receiverOptedIn, receiverAlgoNeededForClaim] = (
    await appClient
      .newGroup()
      .arc59GetSendAssetInfo({ args: { asset: assetId, receiver: receiver.toString() } })
      .simulate({ allowUnnamedResources: true })
  ).returns[0]!;

  // If the receiver has opted in, just send the asset directly
  if (receiverOptedIn) {
    await algorand.send.assetTransfer({
      sender,
      receiver,
      assetId,
      amount: 1n,
    });

    return;
  }

  // Create a composer to form an atomic transaction group
  const group = appClient.newGroup();

  // If the MBR is non-zero, send the MBR to the router
  if (mbr || receiverAlgoNeededForClaim) {
    const mbrPayment = await algorand.createTransaction.payment({
      sender,
      receiver: arc59RouterAddress,
      amount: algokit.microAlgos(Number(mbr + receiverAlgoNeededForClaim)),
    });

    group.addTransaction(mbrPayment);
  }

  // If the router is not opted in, add a call to arc59OptRouterIn to do so
  if (!routerOptedIn) group.arc59OptRouterIn({ args: { asa: assetId } });

  /** The box of the receiver's pubkey will always be needed */
  const boxes = [algosdk.decodeAddress(receiver.toString()).publicKey];

  /** The address of the receiver's inbox */
  const inboxAddress = (
    await appClient
      .newGroup()
      .arc59GetInbox({ args: { receiver: receiver.toString() }, boxReferences: boxes })
      .simulate()
  ).returns[0]!;

  // The transfer of the asset to the router
  const axfer = await algorand.createTransaction.assetTransfer({
    sender,
    receiver: arc59RouterAddress,
    assetId,
    amount: 1n,
  });

  // An extra itxn is if we are also sending ALGO for the receiver claim
  const totalItxns = itxns + (receiverAlgoNeededForClaim === 0n ? 0n : 1n);

  group.arc59SendAsset({
    args: { axfer, receiver: receiver.toString(), additionalReceiverFunds: receiverAlgoNeededForClaim },
    extraFee: algokit.microAlgos(1000 * Number(totalItxns)),
    boxReferences: boxes,
    accountReferences: [receiver, inboxAddress],
    assetReferences: [assetId],
  });

  // Disable resource population to ensure that our manually defined resources are correct
  algokit.Config.configure({ populateAppCallResources: false });

  // Send the transaction group
  await group.send();

  // Re-enable resource population
  algokit.Config.configure({ populateAppCallResources: true });
}

/**
 * Claim an asset from the ARC59 inbox
 *
 * @param appClient The ARC59 client generated by algokit
 * @param assetId The ID of the asset to claim
 * @param claimer The address of the account claiming the asset
 * @param algorand The AlgorandClient instance to use to send transactions
 */
async function arc59Claim(
  appClient: Arc59Client,
  assetId: bigint,
  claimer: algosdk.Address,
  algorand: algokit.AlgorandClient
) {
  const group = appClient.newGroup();

  // Check if the claimer has opted in to the asset
  let claimerOptedIn = false;
  try {
    await algorand.asset.getAccountInformation(claimer, assetId);
    claimerOptedIn = true;
  } catch (e) {
    // Do nothing
  }

  const inbox = (
    await appClient
      .newGroup()
      .arc59GetInbox({ args: { receiver: claimer.toString() } })
      .simulate({ allowUnnamedResources: true })
  ).returns[0]!;

  let totalTxns = 3;

  // If the inbox has extra ALGO, claim it
  const inboxInfo = await algorand.account.getInformation(inbox);
  if (inboxInfo.minBalance < inboxInfo.balance) {
    totalTxns += 2;
    group.arc59ClaimAlgo({ sender: claimer, args: [], staticFee: (0).algo() });
  }

  // If the claimer hasn't already opted in, add a transaction to do so
  if (!claimerOptedIn) {
    group.addTransaction(await algorand.createTransaction.assetOptIn({ assetId, sender: claimer }));
  }

  group.arc59Claim({ args: { asa: assetId }, extraFee: algokit.microAlgos(1000 * (totalTxns - 1)), sender: claimer });

  await group.send();
}

describe('Arc59', () => {
  let appClient: Arc59Client;
  let assetOne: bigint;
  let assetTwo: bigint;
  let alice: algosdk.Account;
  let bob: algosdk.Account;
  let algorand: algokit.AlgorandClient;

  beforeEach(fixture.beforeEach);

  beforeAll(async () => {
    await fixture.beforeEach();
    const { testAccount } = fixture.context;
    algorand = fixture.algorand;

    const factory = new Arc59Factory({ algorand, defaultSender: testAccount });

    appClient = (await factory.send.create.createApplication({ args: [] })).appClient;

    const oneResult = await algorand.send.assetCreate({
      sender: testAccount.addr,
      unitName: 'one',
      total: 100n,
    });

    assetOne = BigInt(oneResult.confirmation.assetIndex!);

    const twoResult = await algorand.send.assetCreate({
      sender: testAccount.addr,
      unitName: 'two',
      total: 100n,
    });
    assetTwo = BigInt(twoResult.confirmation.assetIndex!);

    alice = testAccount;

    await appClient.appClient.fundAppAccount({ amount: algokit.microAlgos(100_000), note: 'initial funding' });
  });

  test('routerOptIn', async () => {
    await appClient.appClient.fundAppAccount({ amount: algokit.microAlgos(100_000) });
    await appClient.send.arc59OptRouterIn({ args: { asa: assetOne }, extraFee: algokit.microAlgos(1_000) });

    const routerBalance = (await algorand.asset.getAccountInformation(appClient.appAddress, assetOne)).balance;
    expect(routerBalance).toBe(0n);
  });

  test('Brand new account getSendAssetInfo', async () => {
    const res = await appClient.send.arc59GetSendAssetInfo({
      args: { asset: assetOne, receiver: algosdk.generateAccount().addr.toString() },
      extraFee: algokit.microAlgos(1_000),
    });

    const [
      itxns,
      mbr,
      routerOptedIn,
      receiverOptedIn,
      receiverAlgoNeededForClaim,
      receiverAlgoNeededForWorstCaseClaim,
    ] = res.return!;

    expect(itxns).toBe(5n);
    expect(mbr).toBe(228_100n);
    expect(routerOptedIn).toBe(true);
    expect(receiverOptedIn).toBe(false);
    expect(receiverAlgoNeededForClaim).toBe(201_000n);
    expect(receiverAlgoNeededForWorstCaseClaim).toBe(201_000n);
  });

  test('Brand new account sendAsset', async () => {
    const { testAccount } = fixture.context;
    bob = testAccount;
    algorand.account.setSignerFromAccount(bob);

    await arc59SendAsset(appClient, assetOne, alice.addr, bob.addr, algorand);
  });

  test('Existing inbox sendAsset (existing asset)', async () => {
    await arc59SendAsset(appClient, assetOne, alice.addr, bob.addr, algorand);
  });

  test('Existing inbox sendAsset (new asset)', async () => {
    await arc59SendAsset(appClient, assetTwo, alice.addr, bob.addr, algorand);
  });

  test('claim', async () => {
    await arc59Claim(appClient, assetOne, bob.addr, algorand);

    const bobAssetInfo = await algorand.asset.getAccountInformation(bob.addr, assetOne);

    expect(bobAssetInfo.balance).toBe(2n);
  });

  test('reject', async () => {
    const newAsset = BigInt(
      (await algorand.send.assetCreate({ sender: alice.addr, total: 1n })).confirmation.assetIndex!
    );
    await arc59SendAsset(appClient, newAsset, alice.addr, bob.addr, algorand);

    await appClient.send.arc59Reject({
      sender: bob.addr,
      args: { asa: newAsset },
      extraFee: algokit.microAlgos(2_000),
    });
  });

  test('claim from 0-ALGO account', async () => {
    const receiver = algorand.account.random();

    await arc59SendAsset(appClient, assetOne, alice.addr, receiver.addr, algorand);

    await arc59Claim(appClient, assetOne, receiver.addr, algorand);

    const receiverAssetInfo = await algorand.asset.getAccountInformation(receiver.addr, assetOne);

    expect(receiverAssetInfo.balance).toBe(1n);
  });

  test('two claims from 0-ALGO account', async () => {
    const receiver = algorand.account.random();
    await arc59SendAsset(appClient, assetOne, alice.addr, receiver.addr, algorand);
    await arc59SendAsset(appClient, assetTwo, alice.addr, receiver.addr, algorand);

    await arc59Claim(appClient, assetOne, receiver.addr, algorand);
    await arc59Claim(appClient, assetTwo, receiver.addr, algorand);

    const receiverAssetInfoOne = await algorand.asset.getAccountInformation(receiver.addr, assetOne);
    const receiverAssetInfoTwo = await algorand.asset.getAccountInformation(receiver.addr, assetTwo);

    expect(receiverAssetInfoOne.balance).toBe(1n);
    expect(receiverAssetInfoTwo.balance).toBe(1n);
  });

  test('claim from abnormal ALGO balance', async () => {
    const receiver = algorand.account.random();

    await algorand.send.payment({ sender: alice.addr, receiver: receiver.addr, amount: algokit.microAlgos(123_456) });

    await arc59SendAsset(appClient, assetOne, alice.addr, receiver.addr, algorand);
    await arc59Claim(appClient, assetOne, receiver.addr, algorand);

    const receiverAssetInfo = await algorand.asset.getAccountInformation(receiver.addr, assetOne);

    expect(receiverAssetInfo.balance).toBe(1n);
  });

  test('arc59GetSendAssetInfo with small amount of ALGO in inbox', async () => {
    const receiver = algorand.account.random();

    await arc59SendAsset(appClient, assetOne, alice.addr, receiver.addr, algorand);
    await arc59Claim(appClient, assetOne, receiver.addr, algorand);

    const inbox = (
      await appClient
        .newGroup()
        .arc59GetInbox({ args: { receiver: receiver.addr.toString() } })
        .simulate({ allowUnnamedResources: true })
    ).returns[0]!;

    await algorand.send.payment({
      sender: alice.addr,
      receiver: inbox,
      amount: algokit.microAlgos(1),
    });

    await appClient
      .newGroup()
      .arc59GetSendAssetInfo({ args: { asset: assetTwo, receiver: receiver.addr.toString() } })
      .simulate({ allowUnnamedResources: true });
  });
});
