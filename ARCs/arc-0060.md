---
arc: 60
title: Algorand Wallet Structured Data Signing API
description: API function for signing structured data
author: Stefano De Angelis (@deanstef)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/284
status: Draft
type: Standards Track
category: Interface
created: 2024-02-28
requires: 1
---

# Algorand Wallet Structured Data Signing API

> This ARC is inspired by [ARC-1](./arc-0001.md).

## Abstract

ARC-1 defines a standard for signing Algorand transactions that are represented as structured objects. This proposal extends the signing process to byte arrays encoded with a standardized structure.

[ARC-60](./arc-0060.md) defines an API for wallets to sign structured data that are not Algorand transactions.

## Motivation

Signing data is a common and critical operation. Users may need to sign data for multiple reasons (e.g. delegate signatures, DIDs, signing documents, authentication).

Algorand wallets need a standard approach to byte signing to unlock self-custodial services and protect users from malicious and attack-prone signing workflows.

This ARC provides a standard API for bytes signing. The API encodes byte arrays to be signed into well-structured JSON schemas together with additional metadata. It requires wallets to validate the signing inputs, notify users about what they are signing and warn them in case of dangerous signing requests.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative

### Overview

> This section is non-normative

ARC-60 defines a function `signData(signingData, metadata)` for signing data.

`signingData` is a `StdSigData` object composed of the signing `data` that instantiates a known JSON Schema and the `signer`'s public key.

`metadata` is a `StdSignMetadata` object that describes the signature `scope`, the JSON `schema`, and the `encoding` used to represent the signing bytes. The JSON schema takes two elements: the `bytes` being signed and an optional `prefix`.

Ultimately, the function computes the message to be signed as `msg=(<prefix> || <data.bytes>)` and returns the signature `Sig(msg, sk)` where `sk` is the `signer`'s signing key.

There are two possible use cases for `signData`:

1. Sign data with one signer that the wallet knows. For example:

```json
{
  "data": "/{.../}",
  "signer": "xxxx"
}
{
  "scope": "...",
  "schema": "/{.../}",
  "encoding": "..."
}
```

2. Sign data with a hierarchical deterministic (HD) wallet. For example:

```json
{
  "data": "/{.../}",
  "signer": "xxxx",
  "hdPath": {
    "purpose": 44,
    "coinType": 0,
    "account": 0,
    "change": 0,
    "addrIdx": 0
  }
}
{
  "scope": "...",
  "schema": "/{.../}",
  "encoding": "..."
}
```

### Interfaces

> Interfaces are defined in TypeScript. All the objects that are defined are valid JSON objects.

ARC-60 uses interchangeably the terms "throw an error" and "reject a promise with an error".

#### **Interface `SignDataFunction`**

A wallet function `signData` is defined by the interface:

```tsx
export type SignDataFunction = {
    signingData: StdSigData,
    metadata: StdSignMetadata,
}
    => Promise<(Signature | null)>;
```

- `signingData` is a `StdSigData` object (defined below).
- `metadata` is a `StdSignMetadata` object (defined below) that provides additional information on the data being signed, the scope, a JSON schema, and the encoding.

The `signData` function returns a `Signature` object or, in case of error, rejects the promise with an error object `SignDataError`.

#### Interface `HDWalletMetadata`

An `HDWalletMetadata` specifies the derivation path parameters to derive the keys of an HD wallet from the seed.

> HD derivation levels originally from  <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP-44</a>.

```tsx
export interface HDWalletMetadata {
    /**
    * HD Wallet purpose value. First derivation path level. 
    * Hardened derivation is used.
    */
    purpose: number,

    /**
    * HD Wallet coin type value. Second derivation path level.
    * Hardened derivation is used.
    */
    coinType: number,

    /**
    * HD Wallet account number. Third derivation path level.
    * Hardened derivation is used.
    */
    account: number,

    /**
    * HD Wallet change value. Fourth derivation path level.
    * Public derivation is used.
    */
    change: number,

    /**
    * HD Wallet address index value. Fifth derivation path level.
    * Public derivation is used.
    */
    addrIdx: number,
}
```

- `purpose` **SHOULD** be set to `44’` for blockchain accounts.
- `coinType` indicates a derivation subtree for a specific cryptocurrency. It **MUST** be set to `283’` for ALGO according to <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">SLIP-44</a> registered coin types.

The apostrophe in the numbering convention indicates that hardened derivation is used.

#### Interface `StdDataStr`

The `StdDataStr` object is a UTF-8 encoded string that adheres to the JSON schema passed with `metadata`.

```tsx
export type StdDataStr = string;
```

#### Interface `Ed25519Pk`

An `Ed25519Pk` object is a 32-byte public key, point of the ed25519 elliptic curve. The key **MUST NOT** be transformed into an Algorand address.

```tsx
export type Ed25519Pk = Uint8Array;
```

> The wallet **MAY** want to operate directly with standard Algorand addresses. The transformation from a generic key to an Algorand address is left to the implementation. See <a href="https://developer.algorand.org/docs/get-details/accounts/#transformation-public-key-to-algorand-address">Public Key to Algorand Address</a> section of the developer portal.

#### Interface `StdSigData`

A `StdSigData` object represents a structured byte array of data to be signed by a wallet.

```tsx
export interface StdSigData {
    /**
    * The structured arbitrary data compliant with the JSON schema.
    */
    data: StdDataStr;
    
    /**
    * The signer ed25519 public key.
    */
    signer: Ed25519Pk;

    /**
    * Optional HD wallet metadata used to derive
    * the signer ed25519 public key.
    */
    hdPath?: HDWalletMetadata
}
```

- `data` must be validated with the JSON schema in `metadata` (defined below).
- `signer` is a `Ed25519Pk` object (defined below) that represents the signer public key.

#### Interface `Signature`

`Signature` is the produced 64-byte array, ed25519 digital signature of the signed message.

```tsx
export type Signature = Uint8Array;
```

#### Enum `ScopeType`

The `ScopeType` enumerates constant strings with the scope of a signing action.

This ARC introduces two scope types.

| ScopeType | Description |
| --- | --- |
| AUTH | Signature of a basic 32 bytes challenge for authentication. |
| LSIG | Signature of an Algorand program for delegation. |

For each `ScopeType` there is associated one JSON schema (see below).

Any extension of this ARC **SHOULD** adopt an existing `ScopeType`, or introduce a new one (with the respective JSON schema).

#### Interface `StdSignMetadata`

A `StdSignMetadata` object specifies the metadata for the `StdSigData`.

```tsx
export interface StdSignMetadata {
    /**
    * The scope value of the signing data request.
    */
    scope: ScopeType;

    /**
    * JSON schema for the signing data.
    */
    schema: string;

    /**
    * Optional encoding used to represent the signing bytes in the schema.
    */
    encoding?: string;
}
```

- `schema` JSON schema to be used according to the `scope`. ARC-60 compliant JSON schemas must have two mandatory fields:
  - `ARC60Domain` domain separator for the signing bytes.
  - `bytes` signing bytes.
- `encoding` specifies the encoding used for the `schema.bytes` field. If not specified, encoding should be `base64`.

> The JSON schema is inspired by <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712: Typed structured data hashing and signing proposal</a>.

##### Example: AUTH JSON Schema

JSON schema for signing a 32-byte array representing an authentication challenge; `ScopeType=AUTH`. In this example, the `StdDataStr` **MUST** adhere to the following schema

```json
{
  "type": "object",
  "properties": {
    "ARC60Domain": {
      "type": "string",
      "description": "The ARC-60 domain separator"
    },
    "bytes": {
      "type": "array",
      "items": {
        "type": "integer",
        "minimum": 0,
        "maximum": 255
      },
      "description": "Challenge to be signed for authentication",
      "maxItems": 32
    }
  },
  "required": ["ARC60Domain", "bytes"]
}
```

- The `ARC60Domain` object indicates the domain separator to be used for signing. It **SHOULD** be set to `"arc60"` or empty `""`. Algorand transaction domain separators `TX` and `TG` **MUST** be forbidden.
- The `bytes` object is the byte array of data being signed. In the example, it is a 32-byte challenge to be signed for authentication scope. The `bytes` field cannot be a valid Algorand transaction, therefore it **MUST NOT** be prepended with a known domain separator `TX` or `TG`.

> Algorand domain separators can be found in the <a href="https://github.com/algorandfoundation/specs/blob/master/dev/crypto.md#domain-separation">Algorand specs</a> and in the <a href="https://github.com/algorand/go-algorand/blob/master/protocol/hash.go#L21">Go type HashID</a>.

A valid `StdDataStr` object for `ScopeType=AUTH` should look like the following:

```json
{
  "ARC60Domain" : "arc60",
  "bytes" : [99, 50, 97, 57, 51, 99, ..., 57, 49, 53]
}
```

#### Error interface `SignDataError`

The `SignDataError` object extends the `SignTxnsError` defined in [ARC-1](./arc-0001.md).

```ts
export interface SignDataError extends Error {
  code: number;
  data?: any;
  failingSignData: (StdSigData | null);
}
```

`SignDataError` uses the same error codes of `SignTxnsError` as well as the following codes:

| Status Code | Name | Description |
| --- | --- | --- |
| 4600 | Invalid scope | The scope of the signing action is not recognized by the wallet |
| 4601 | Invalid schema | The schema does not comply with ARC-60 requirements |
| 4602 | Invalid encoding | Data cannot be decoded with the given encoding |

### Semantic Requirements

The call `signData(signingData, metadata)` **MUST** either return the signed data `ret` or reject the call throwing an error `err`.

> Following [ARC-1](./arc-0001.md) terminology, in this ARC the term **Rejecting** means throwing an error with `err.code=4300`.

Upon calling `signData(signingData,, metadata)`:

- the `signingData` and `metadata` **MUST NOT** be `null`, otherwise the wallet **MUST** reject the call.
- `signingData.data` **MUST** be valid respect the JSON schema in `metadata.schema`. If the validation fails, the call **MUST** be rejected with a `4300` error.
- if the encoding `metadata.encoding` is present, it **MUST** be used to decode `signingData.data.bytes`.
- the wallet **MUST** prepare the signing message as `msg=(<signingData.data.bytes>)`.
  - if the value of `ARC60Domain` is not empty than it **MUST** be used as `prefix`: `msg=(<prefix> || <signingData.data.bytes>)`.
- the wallet **MUST** ask users for signing confirmation. It **MUST** display a message (defined in Display message) providing the `ScopeType`, `signer`, and the `msg` being signed:
  - if the user approves, `msg` **MUST** be signed with the `signer`'s key and `ret` **MUST** be set to the corresponding `Signature`.
  - if the user rejects, the call **MUST** fail with error code `4001`.

Note that if `msg` cannot be signed for any reason, the wallet **MUST** throw an error, such that

- `err.message` **SHOULD** indicate the reason for the error (e.g. specify that `signingData.data` is not a valid JSON object according to `metadata.schema`)
- `err.failingSignData` **SHOULD** return the `StdSigData` object that caused the error, otherwise `null`.

#### Semantic of `StdSigData`

- it **MUST** be a valid `StdSigData` object, otherwise the wallet **MUST** reject.
- `data`:
  - it **MUST** be a valid `StdDataStr` object (UTF-8 encoded), otherwise the wallet **MUST** reject.
  - it **MUST** adhere to `metadata.schema`, otherwise the wallet **MUST** reject.
  - the `data.ARC60Domain` field must be validated against forbidden values:
    - the wallet **MUST** reject if `ARC60Domain="TX"`.
    - the wallet **MUST** reject if `ARC60Domain="TG"`.
  - `data.bytes` must be a valid byte string:
    - it **MUST** be encoded as `metadata.encoding` if present, otherwise `base64`.
    - the wallet **MUST** throw a `4602` error if the decoding fails with the given encoding value.
    - the wallet **MUST** reject if `data.bytes` field is prepended with a forbidden domain separator `TX` or `TG`.
- `signer`:
  - it **MUST** be a valid `Ed25519Pk` object, otherwise the wallet **MUST** reject.
  - the wallet **MUST** reject if the `signer` is unknown.
  - if `hdPath` is specified, the wallet **MUST** reject if `signer` does not correspond the public key derived with the `hdPath` parameters.

- `hdPath`:
  - The wallet **MAY** not support this field. In that case, it **MUST** throw a `4200` error.
  - if specified, it **MUST** be a valid `HDWalletMetadata` object, otherwise the wallet **MUST** reject.
  - if specified and supported, the wallet **MUST** verify that the derivation path resolves to a public key corresponding to `signer`.

#### Semantic of `StdSignMetadata`

- `scope`:
  - it **MUST** be a valid `ScopeType` string, otherwise the wallet **MUST** throw a `4600` error.

- `schema`:
  - it **MUST** be a JSON schema with the properties `ARC60Domain` and `bytes`, otherwise the wallet **MUST** throw a `4601` error.

- `encoding`:
  - if specified, it **MUST** be used to encode `data.bytes`.

#### General Validation

Every input of the `signData(signingData, metadata)` must be validated.

The validation:

- **SHALL NOT** rely on TypeScript typing as this can be bypassed. Types **MUST** be manually verified.
- **SHALL NOT** assume that `signingData.data` complies with `metadata.schema`. The schema **MUST** be manually verified and all the required parameters **MUST** be checked.
- **SHALL NOT** assume to compute signatures with the Algorand SDK `signBytes` function. There is no indirect validation of the passed `signingData` and `metadata` objects on that function. In general, the validation **SHALL NOT** rely on underlying SDKs to validate the inputs of an ARC-60 signing operation.

#### Display message

The wallet **MUST** display a message for any signing request. The message **MUST** be computed dynamically taking as inputs the `metadata.scope`, the `signingData.signer`, and the message being signed `msg`.

> The `message` structure is left to the implementation. An example is:
>
> `You are about to sign <msg> with scope <metadata.scope> and signer <signingData.signer>`.

The wallet **SHOULD** display a warning in the message if the `ScopeType` is a `LSIG`.

## Rationale

This API was designed to enable the secure signing of structured data with Algorand wallets. The API:

- Is generic to _pure_ ed25519 key pairs and does not require key manipulation
- Is easy to extend with custom JSON schema to support future signing use cases (e.g. authentication)
- Is secure by design preventing malicious applications from tricking users into signing malicious data or in the worst cases approving malicious transactions.

This API was not designed to sign Algorand transactions or a group of transactions (see ARC-1 instead).

## Backwards Compatibility

This ARC is not backward compatible with [ARC-47](./arc-0047.md) Logic Signature Template.

ARC-47 introduces the method `algo_templatedLsig` that takes a `LogicSignatureDescription` object and returns the signature of a logic signature program for delegation.

An alternative using the ARC-60 `signData(signingData, metadata)` is given below, where:

- `signingData.data` **MUST** specify:
  - the `LogicSignatureDescription` object as detailed in ARC-47
  - the `values` of the templated variables and the `hash` of the expected program
  - the `ARC60Domain` must be set to the domain separator `"Program"`, as specified in the <a href="https://github.com/algorandfoundation/specs/blob/master/dev/crypto.md#domain-separation">Algorand specs</a>.

- `metadata` **MUST** specify:
  - an extended ARC-60 compatible JSON schema
  - `ScopeType` is set to `LSIG`.

The extended schema can be found in the `../assets/arc-0060` folder with the file [lsig-schema.json](../assets/arc-0060/lsig-schema.json).

### Semantics for signing a Logic Signature

- if the `metadata.scope` is set to `LSIG`:
  - the `ARC60Domain` value **MUST** be equal to the byte array corresponding to the prefix `"Program"`.
  - the JSON schema **MUST** define the `signingData.data.bytes` field as an array of objects, such as the `LogicSignatureDescription`, `values`, and `hash`.
  - the wallet **MUST** follow the ARC-47 specification: compile the program from the received template and check its integrity with the `hash`.
  - the compiled program **MUST** be used with the prefix to compute the signing message `msg`, as `msg="Program" || <compiled_lsig>`.

## Test Cases

N/A

## Reference Implementation

A reference implementation is available in the `../assets/arc-0060` folder.

- [auth-schema.json](../assets/arc-0060/auth-schema.json) provides the ARC-60 JSON schema for `ScopeType=AUTH`.
- [lsig-schema.json](../assets/arc-0060/lsig-schema.json) provides the ARC-60 JSON schema for `ScopeType=LSIG`.
- [wallet.ts](../assets/arc-0060/wallet.ts) contains a simple TypeScript script showing how wallets can implement the `SignDataFunction` interface.

## Security Considerations

Users signing bytes can be tricked into signing malicious messages being exposed to man-in-the-middle attacks.

Users must be aware of what they are signing and for what purpose. The wallet **MUST** always compute a new message dynamically according to the received `signingData` and `metadata`. This prevents the injection of malicious or misleading messages and provides a clear scope of the signing action.

Wallets only support known `ScopeTypes` and schemas. It ensures that signing actions have a clear scope and mitigates the risk of producing unexpected signatures.

## Copyright

Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
