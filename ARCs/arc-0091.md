---
arc: 91
title: Encrypted Multisig (ARC-55 Extension)
description: This ARC defines an extension to ARC-55, adding per-signer encrypted transaction storage using ECDH key exchange and ChaCha20-Poly1305 encryption.
author: Steve Ferrigno <steve.ferrigno@algorand.foundation>, Bruno Martins <bruno.martins@algorand.foundation>
discussions-to: https://github.com/algorandfoundation/ARCs/discussions/<tbd>
status: Draft
type: Standards Track
category: Interface
sub-category: Wallet
created: 2026-02-11
requires: 55
---

## Abstract

This ARC extends [ARC-55](./arc-0055.md) by adding per-signer encrypted transaction storage. The only change from ARC-55 is the addition of a `signerIndex` parameter that allows each signer to store and retrieve their own encrypted version of each transaction. Encryption is performed off-chain using ECDH between the admin and each signer, with the resulting shared secret hashed via Blake2b and used as the key for ChaCha20-Poly1305 stream encryption.

## Motivation

ARC-55 stores transactions in plaintext, making them visible on-chain before execution. By encrypting each transaction specifically for each signer using their public key, transaction contents remain confidential among authorized parties until ready for execution.

## Specification

### ABI Changes from ARC-55

The only modification to the ARC-55 ABI is the addition of a `signerIndex` parameter (type `uint8`) to transaction storage methods:

**Modified Methods:**

| Method | ARC-55 Signature | ARC-91 Signature |
|--------|----------------|------------------|
| `arc55_getTransaction` | `(uint64,uint8)byte[]` | `(uint64,uint8,uint8)byte[]` |
| `arc55_addTransaction` | `(pay,uint64,uint8,byte[])void` | `(pay,uint64,uint8,uint8,byte[])void` |
| `arc55_removeTransaction` | `(uint64,uint8)void` | `(uint64,uint8,uint8)void` |

The `signerIndex` parameter identifies which signer's encrypted version to store or retrieve, allowing each signer to have their own encrypted copy of the same transaction.

### Encryption Process

Encryption and decryption occur entirely off-chain. The contract only stores and retrieves opaque byte arrays.

#### Key Derivation (ECDH + Blake2b)

For each signer in the multisig, the admin derives an encryption key as follows:

1. **ECDH Exchange**: The admin performs ECDH using:
   - Their own private key: `adminPriv`
   - The signer's public key: `signerPub`
   
   This produces a shared secret point on the curve.

2. **Serialization**: The shared point is serialized to 32 bytes using Ed25519 point compression (only the x-coordinate).

3. **Hashing with Blake2b**: The 32-byte point is hashed using **Blake2b-256** to produce a 256-bit encryption key:
   ```
   encryptionKey = Blake2b-256(sharedPoint)
   ```

#### Encryption (ChaCha20-Poly1305)

Each transaction is encrypted using **ChaCha20-Poly1305**:

- **Key**: The 256-bit output from Blake2b-256 above
- **Nonce**: A 96-bit (12-byte) nonce, which **MUST** be unique per encryption operation. The nonce **SHOULD** be derived deterministically from the transaction group nonce and signer index, or generated randomly and prepended to the ciphertext. - **Plaintext**: The transaction bytes (msgpack-encoded unsigned transaction)
- **Ciphertext format**: `[nonce (12 bytes)] || [encrypted data] || [tag (16 bytes)]`

- `note on using stream ciphers`: **Re-using nonces in stream cipher modes is catastrophic for security as encrypted data can be collected and XOR techniques can be used to recover plaintext.** (See [Stream Cipher Key & Nonce Reuse](https://hacker101.linuxsec.org/vulnerabilities/stream_reuse))

The resulting encrypted transaction is what gets passed to `arc55_addTransaction` and stored in the contract.

#### Decryption Process

When a signer retrieves their encrypted transaction:

1. Retrieve ciphertext from contract using their `signerIndex`
2. Extract nonce from first 12 bytes
3. Perform ECDH using:
   - Their own private key: `signerPriv`
   - Admin's public key: `adminPub`
4. Serialize shared point and hash with Blake2b-256 to derive the same key
5. Decrypt using ChaCha20-Poly1305 with the extracted nonce
6. Verify the authentication tag to detect tampering

### Storage Changes

The only change to storage is the box key format for transaction boxes:

| ARC | Box Key Format | Size | Description |
|-----|---------------|------|-------------|
| ARC-55 | `{nonce}:{index}` | 9 bytes (uint64 + uint8) | Single version per transaction |
| ARC-91 | `{nonce}:{index}:{signerIndex}` | 10 bytes (uint64 + uint8 + uint8) | Per-signer encrypted version |

**Example for a transaction group with 3 transactions and 3 signers:**

```
// Transaction 0
"txn:1:0:0" → encrypted_version_for_signer_0  // 10-byte key
"txn:1:0:1" → encrypted_version_for_signer_1
"txn:1:0:2" → encrypted_version_for_signer_2

// Transaction 1
"txn:1:1:0" → encrypted_version_for_signer_0
"txn:1:1:1" → encrypted_version_for_signer_1
"txn:1:1:2" → encrypted_version_for_signer_2

// etc.
```

### Minimum Balance Requirement

The MBR for storing transactions increases by 400 microALGO per transaction due to the additional byte in the box key:

```
ARC-55: MBR = 2500 + 400 × (9 + transactionSize)
ARC-91: MBR = 2500 + 400 × (10 + transactionSize)
```

For N signers, storage costs are multiplied by N since each signer stores their own encrypted copy.

## Usage Flow

1. **Admin creates transaction group**: Calls `arc55_newTransactionGroup()` (unchanged from ARC-55)

2. **Admin encrypts and stores for each signer**:
   ```typescript
   const txnBytes = transaction.toByte()
   
   for (let i = 0; i < signers.length; i++) {
     // Derive key via ECDH + Blake2b
     const sharedPoint = ed255dh(adminPriv, signers[i].pubkey)
     const key = blake2b(sharedPoint)
     
     // Encrypt with ChaCha20-Poly1305
     const nonce = deriveNonce(groupNonce, i)
     const encrypted = chacha20poly1305.encrypt(txnBytes, key, nonce)
     const payload = nonce || encrypted.ciphertext || encrypted.tag
     
     // Store with signer index
     await contract.arc55_addTransaction(costs, groupNonce, txnIndex, i, payload)
   }
   ```

3. **Each signer retrieves and decrypts**:
   ```typescript
   // Signer knows their index (e.g., signer 1)
   const encrypted = await contract.arc55_getTransaction(groupNonce, txnIndex, 1)
   
   // Derive same key via ECDH + Blake2b
   const sharedPoint = ed255dh(signerPriv, adminPub)
   const key = blake2b(sharedPoint)
   
   // Decrypt
   const txnBytes = chacha20poly1305.decrypt(encrypted, key)
   ```

4. **Sign and submit**: Signers use standard ARC-55 `arc55_setSignatures()` (unchanged)

### Design Rationale for Admin -> Signer Encryption

In this design every encryption key derived is from the admin to each signer. Theres a couple reasons for this:
- **Simplicity**: The admin is responsible for creating and managing transactions, so it makes sense for the admin to handle encryption. Signers only need to perform decryption.
- **No need for orchestration**: If the signing quorum would have to share a common key to encrypt, this would require communication and orchestration among signers to establish shared keys, which adds complexity and potential points of failure. With admin-to-signer encryption, each signer can independently derive their key without needing to coordinate with others.

- **Why ECDH only from the admin -> signer**: If we were to design the scheme were each signer derives a unique key for each otehr signer, this would require N*(N-1) ECDH operations for N signers, which is inefficient and would explode complexity and state management in the contract. With admin-to-signer encryption, only N ECDH operations are needed.

## Security Considerations

1. **Off-chain encryption**: The smart contract never sees plaintext or performs cryptographic operations. All encryption/decryption happens client-side.

2. **ECDH security**: The shared secret is ephemeral and derived per encryption operation. Even if one transaction's key is compromised, other transactions remain secure.

3. **Blake2b hashing**: Prevents direct use of raw ECDH output, providing domain separation and ensuring uniform key distribution.

4. **ChaCha20-Poly1305**: Provides authenticated encryption. The Poly1305 tag ensures ciphertext integrity and prevents tampering.

5. **Nonce uniqueness**: Critical for ChaCha20 security. Nonces **MUST** never be reused with the same key.

6. **Public metadata**: While transaction contents are encrypted, the following remain public:
   - Transaction group nonce
   - Number of transactions in group
   - Number of signers
   - Transaction sizes (revealed by box storage)
   - Which signer index has signed (signature boxes)


