---
arc: 23
title: Append the hash of the contract descriptor to the compiled application's bytes
status: Draft
---

# Append the hash of the contract descriptor to the compiled application bytes

## Summary

The following document introduces a convention for appending the hash of the contract descriptor (as described in [ARC-4](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md)) to the compiled application's bytes.

## Abstract

The goal of this convention is to standardize the process of verifying and interacting with smart contracts.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).

> Comments like this are non-normative.

## Overview

By appending the hash of the contract descriptor, any user with access to the blockchain could easily verify the ABI of an application and interact with it.

> The goal is to have an off-chain ABI repository, where entries are indexed by the hash of the contract descriptor.

### Hash

The hash is defined as follow:
```
SHA-512/256("arc0023" || <content of the metadata JSON file>)
```
In other words, it is the SHA-512/256 hash of the content of the metadata JSON file prefixed by the 7-byte string `arc0023`.
### Appending

The encoded object bytes are appended to the compiled application as a [bytecblock](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#bytecblock-bytes) containing 1 byte constant which is the encoded object.
> The reason to use `bytecblock` is that adding a `bytecblock` opcode at the end of a TEAL program does not change the semantics of the program, as long as: opcodes are properly aligned, there is no jump after the last position (that would make the program fail without `bytecblock`), and there is enough space left to add the opcode.
The size of the compiled application + the bytecblock should not exceed the maximum size of a compiled application according to the latest consensus parameters supported by the compiler.

### Encoding

The encoded object is a MessagePack encoding of the following object:
```JSON
{"arc23": <hash as a 32-byte array as defined above>}
```

### Example

Let's consider the following example contract:
```python
calc_abi = '''{
  "name": "Calculator",
  "desc": "Contract of a basic calculator supporting additions and multiplications. Implements the Calculator interface.",
  "methods": [
    {
      "name": "add",
      "desc": "Calculate the sum of two 64-bit integers",
      "args": [
        { "type": "uint64", "name": "a", "desc": "The first term to add" },
        { "type": "uint64", "name": "b", "desc": "The second term to add" }
      ],
      "returns": { "type": "uint128", "desc": "The sum of a and b" }
    },
    {
      "name": "multiply",
      "desc": "Calculate the product of two 64-bit integers",
      "args": [
        { "type": "uint64", "name": "a", "desc": "The first factor to multiply" },
        { "type": "uint64", "name": "b", "desc": "The second factor to multiply" }
      ],
      "returns": { "type": "uint128", "desc": "The product of a and b" }
    }
  ]
}'''
```

and the associated TEAL script:
```python
calc_teal = '''#pragma version 5
txn ApplicationID
int 0
==
bnz main_l16
txn OnCompletion
int OptIn
==
bnz main_l15
txn OnCompletion
int CloseOut
==
bnz main_l14
txn OnCompletion
int DeleteApplication
==
bnz main_l13
txn OnCompletion
int UpdateApplication
==
bnz main_l12
txn OnCompletion
int NoOp
==
bnz main_l7
err
main_l7:
txna ApplicationArgs 0
byte 0x8aa3b61f
==
bnz main_l11
txna ApplicationArgs 0
byte 0xe395f262
==
bnz main_l10
err
main_l10:
byte 0x151f7c75
txna ApplicationArgs 1
btoi
txna ApplicationArgs 2
btoi
mulw
itob
concat
log
int 1
return
main_l11:
byte 0x151f7c75
txna ApplicationArgs 1
btoi
txna ApplicationArgs 2
btoi
addw
itob
concat
log
int 1
return
main_l12:
int 0
return
main_l13:
int 0
return
main_l14:
int 1
return
main_l15:
int 1
return
main_l16:
int 1
return'''
```

With the following python script we can generate the hash and append it to the compiled application, according to arc-23:
```python
from Cryptodome.Hash import SHA512
import msgpack

def sha512_256(data: bytes):
    return SHA512.new(data=data, truncate='256').digest()

def hash_contract_descriptor(contract_descriptor: bytes):
    return sha512_256(b'arc0023' + contract_descriptor)

def encode_arc23_object(contract_descriptor: bytes):
    return msgpack.packb({'arc23': hash_contract_descriptor(contract_descriptor)})
    
def create_teal_bytecblock(bytes_slice):
    return f'bytecblock {" ".join(["0x"+b.hex() for b in bytes_slice])}'

def append_contract_descriptor_to_teal(teal_script: str, contract_descriptor_str: str):
    cd_bytes = contract_descriptor_str.encode()
    enc_arc23_obj = encode_arc23_object(cd_bytes)
    bytecblk = create_teal_bytecblock([enc_arc23_obj])
    return f'{teal_script}\n{bytecblk}\n'
    
print(append_contract_descriptor_to_teal(calc_teal, calc_abi))
```

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
