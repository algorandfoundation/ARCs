---
arc: 23
title: Append the hash of the contract description to the compiled application's bytes
status: Draft
---

# Append the hash of the contract description to the compiled application bytes

## Summary

The following document introduces a convention for appending the hash of the contract description (as described in [ARC-4](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md)) to the compiled application's bytes.

## Abstract

The goal of this convention is to standardize the process of verifying and interacting with smart contracts.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).

> Comments like this are non-normative.

## Overview

By appending the hash of the contract description, any user with access to the blockchain could easily verify the ABI of an application and interact with it.

> The goal is to have an off-chain ABI repository, where entries are indexed by the hash of the contract description.

### Hash

The hash is defined as follow:
```
SHA-512/256("arc0023" || <content of the metadata JSON file>)
```
In other words, it is the SHA-512/256 hash of the content of the metadata JSON file prefixed by the 7-byte string `arc0023`.
### Appending

The encoded object bytes are appended to the compiled application as a [bytecblock](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#bytecblock-bytes) containing 1 byte constant which is the encoded object.
> The reason to use `bytecblock` is that adding a `bytecblock` opcode at the end of a TEAL program does not change the semantics of the program, as long as: opcodes are properly aligned, there is no jump after the last position (that would make the program fail without `bytecblock`), and there is enough space left to add the opcode.
The size of the compiled application + the bytecblock should not exceed the maximum size of a compiled application according to the latest consensus parameters supported by the compiler.

### Encoding

The encoded object is a MessagePack encoding of the following object:
```JSON
{"arc23": <hash as a 32-byte array as defined above>}
```

### Example

Let's consider the following example contract:
```python
calc_abi = '''{
  "name": "Calculator",
  "desc": "Contract of a basic calculator supporting additions and multiplications. Implements the Calculator interface.",
  "methods": [
    {
      "name": "add",
      "desc": "Calculate the sum of two 64-bit integers",
      "args": [
        { "type": "uint64", "name": "a", "desc": "The first term to add" },
        { "type": "uint64", "name": "b", "desc": "The second term to add" }
      ],
      "returns": { "type": "uint64", "desc": "The sum of a and b" }
    },
    {
      "name": "multiply",
      "desc": "Calculate the product of two 64-bit integers",
      "args": [
        { "type": "uint64", "name": "a", "desc": "The first factor to multiply" },
        { "type": "uint64", "name": "b", "desc": "The second factor to multiply" }
      ],
      "returns": { "type": "uint64", "desc": "The product of a and b" }
    }
  ]
}'''
```

and the associated TEAL script:
```python
from pyteal import *  # Python 3.8.3, pyteal==0.10.1

calc_teal = compileTeal(
            Cond(
                [
                    Txn.application_args.length() == Int(0),
                    Cond(
                        [Txn.application_id() == Int(0), Approve()],
                        [Txn.on_completion() == OnComplete.OptIn, Approve()],
                        [Txn.on_completion() == OnComplete.CloseOut, Approve()],
                        [Txn.on_completion() == OnComplete.DeleteApplication, Reject()],
                        [Txn.on_completion() == OnComplete.UpdateApplication, Reject()],
                    )
                ],
                [
                    Txn.on_completion() == OnComplete.NoOp,
                    Cond(
                        [
                            Txn.application_args[0] == Bytes('base16', 'fe6bdf69'),  # add(uint64,uint64)uint64
                            Seq([
                                Log(
                                    Concat(
                                        Bytes('base16', '151f7c75'),
                                        Itob(Add(Btoi(Txn.application_args[1]), Btoi(Txn.application_args[2])))
                                    )
                                ),
                                Approve()
                            ])
                        ],
                        [
                            Txn.application_args[0] == Bytes('base16', '766083a7'),  # multiply(uint64,uint64)uint64
                            Seq([
                                Log(
                                    Concat(
                                        Bytes('base16', '151f7c75'),
                                        Itob(Mul(Btoi(Txn.application_args[1]), Btoi(Txn.application_args[2])))
                                    )
                                ),
                                Approve()
                            ])
                        ],

                    )
                ]
            ), mode=Mode.Application, version=5
        )
```

With the following python script we can generate the hash and append it to the compiled application, according to arc-23:
```python
import hashlib
import msgpack  # Python 3.8.3, msgpack==1.0.2

def sha512_256(data: bytes):
    return hashlib.new(name='sha512_256', data=data).digest()

def hash_contract_descriptor(contract_descriptor: bytes):
    return sha512_256(b'arc0023' + contract_descriptor)

def encode_arc23_object(contract_descriptor: bytes):
    return msgpack.packb({'arc23': hash_contract_descriptor(contract_descriptor)})
    
def create_teal_bytecblock(bytes_slice):
    return f'bytecblock {" ".join(["0x"+b.hex() for b in bytes_slice])}'

def append_contract_descriptor_to_teal(teal_script: str, contract_descriptor_str: str):
    cd_bytes = contract_descriptor_str.encode()
    enc_arc23_obj = encode_arc23_object(cd_bytes)
    bytecblk = create_teal_bytecblock([enc_arc23_obj])
    return f'{teal_script}\n{bytecblk}\n'
    
print(append_contract_descriptor_to_teal(calc_teal, calc_abi))

'''
expected output:

#pragma version 5
txn NumAppArgs
int 0
==
bnz main_l8
txn OnCompletion
int NoOp
==
bnz main_l3
err
main_l3:
txna ApplicationArgs 0
byte 0xfe6bdf69
==
bnz main_l7
txna ApplicationArgs 0
byte 0x766083a7
==
bnz main_l6
err
main_l6:
byte 0x151f7c75
txna ApplicationArgs 1
btoi
txna ApplicationArgs 2
btoi
*
itob
concat
log
int 1
return
main_l7:
byte 0x151f7c75
txna ApplicationArgs 1
btoi
txna ApplicationArgs 2
btoi
+
itob
concat
log
int 1
return
main_l8:
txn ApplicationID
int 0
==
bnz main_l18
txn OnCompletion
int OptIn
==
bnz main_l17
txn OnCompletion
int CloseOut
==
bnz main_l16
txn OnCompletion
int DeleteApplication
==
bnz main_l15
txn OnCompletion
int UpdateApplication
==
bnz main_l14
err
main_l14:
int 0
return
main_l15:
int 0
return
main_l16:
int 1
return
main_l17:
int 1
return
main_l18:
int 1
return
bytecblock 0x81a56172633233c4209f5960218ddd52816a9963c54a8d853876ceaa2f1533205d2b658b1dd75e3b90
'''
```

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
