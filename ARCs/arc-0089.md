---
arc: <to be assigned>
title: Account Recovery via LogicSig Will
description: Two-step executor confirmation for delegated LogicSig-based Algorand account recovery.
author: Sébastien B. (@sb)
discussions-to: https://github.com/algorandfoundation/ARCs/discussions/XXXX
status: Draft
type: Standards Track
category: ARC
subcategory: Application
created: 2024-05-10
requires:
---

## Abstract

This ARC specifies an Algorand account recovery standard that combines an offline delegated LogicSig (LSig) with a stateful application (“AppWill”) to produce an inheritance-style recovery flow. The owner pre-signs a rekey-only transaction bound to an AppCall, while a multisig executor arms and confirms execution before the heir can supply a preimage that unmasks the LSig hash. Optional expiry, executor rotation, and encrypted storage of the LSig blob are supported.

## Motivation

Algorand accounts lack a native inheritance or delayed recovery mechanism that allows heirs to gain control without exposing mnemonics or relying on centralized custodians. Users frequently share private keys or delegate custody, both of which increase risk. This ARC introduces a deterministic, verifiable on-chain process that keeps the owner’s private keys offline, requires staged confirmation by a trusted multisig executor, and empowers heirs to assume control only after satisfying explicit conditions encoded in the AppWill and LogicSig.

## Specification

The key words “**MUST**”, “**MUST NOT**”, “**REQUIRED**”, “**SHALL**”, “**SHALL NOT**”, “**SHOULD**”, “**SHOULD NOT**”, “**RECOMMENDED**”, “**MAY**”, and “**OPTIONAL**” in this document are to be interpreted as described in [RFC‑2119](https://www.ietf.org/rfc/rfc2119.txt).

### Roles and Constants

- `A_owner = PZ7S6RB5J4VJ3XWBEZCNWWTP7MZOHYNL7N6CSM2UTPOYBKF7AECOYUXK3E`
- `A_heir = VKDAH6ECLG2MZ4H5IFH5OQ5ESAFI6KM3VL7Q6XG5R2KEDA7D2L5OFGM3GE`
- `M_exec = 6FWTKZF4CAMDEDN5VMMEXUXWM6Y3I6BDOE7P72Z6ON4KJ2D7QZFSKKDJYA`
- `min_delay = 50000` rounds (~3 days)
- `App ID = 123456789` (placeholder; actual deployed ID **MUST** be substituted inside the LSig)
- `H_lsig` — keccak256 binding the delegated LSig to its execution context

### Components

1. **AppWill** — a stateful smart contract holding per-owner recovery state. It **MUST** expose the ABI methods `set_will`, `arm`, `confirm`, `cancel`, and `bequeath`. It **MAY** expose optional helper methods `rotate_executor` and `store_blob`.
2. **Delegated LogicSig** — an offline-signed LogicSig produced by `A_owner` that authorizes only the rekey transaction defined in this ARC and **MUST** incorporate the validation program listed below.

### Lifecycle State Machine

Per-owner state transitions:

```
IDLE --set_will--> IDLE (initialization)
IDLE --arm--> ARMED (records t1_round)
ARMED --confirm--> READY (requires current round ≥ t1_round + min_delay)
READY --bequeath--> EXECUTED (records execution_round)
Any --cancel--> IDLE (unless EXECUTED)
READY --expiry--> IDLE (if expiry_round configured and passed)
EXECUTED --additional calls--> rejected
```

### Persistent Storage

Implementers **SHOULD** store per-owner data in boxes keyed by `owner`, though local state is acceptable. Required keys:

| Key              | Type        | Size | Description |
|------------------|-------------|------|-------------|
| `status`         | uint/enumeration | 8    | 0=IDLE, 1=ARMED, 2=READY, 3=EXECUTED |
| `heir`           | bytes        | 32   | Address of `A_heir` |
| `executor`       | bytes        | 32   | Address of `M_exec` |
| `min_delay`      | uint64       | 8    | Minimum delay rounds |
| `H_lsig`         | bytes        | 32   | Hash binding LSig |
| `t1_round`       | uint64       | 8    | Round recorded at `arm` |
| `expiry_round`   | uint64       | 8    | Optional expiry (0 disables) |
| `app_id_ctx`     | uint64       | 8    | App ID baked into `H_lsig` |
| `salt`           | bytes        | 32   | Optional randomness contributing to `H_lsig` |
| `execution_round`| uint64       | 8    | Round recorded at `bequeath` |
| `blob_ref`       | bytes        | ≤64  | OPTIONAL pointer/checksum for encrypted blob |
| `encrypted_blob` | bytes (box)  | ≤1024 | OPTIONAL encrypted LogicSig blob |

### Method Semantics

#### `set_will(owner, heir, msig, min_delay, H_lsig, expiry_round?, salt?)`

- Sender **MUST** be `owner`.
- If status is `EXECUTED`, the call **MUST** fail.
- Updates storage, sets `status = IDLE`, clears `t1_round` and `execution_round`.
- Validates `min_delay ≥ 1000` (RECOMMENDED floor) and `msig == M_exec`.
- Verifies `H_lsig = keccak256(program || lsig_sig || heir || msig || app_id || salt)` where:
  - `program` = compiled TEAL bytes.
  - `lsig_sig` = raw signature bytes.
  - `heir`, `msig` = 32-byte addresses.
  - `app_id` = uint64 encoded `AppWill` ID.
  - `salt` = optional bytes (empty string if omitted).
- Stores optional `expiry_round` (0 disables expiry) and `salt`.

#### `arm(owner)`

- Sender **MUST** be `M_exec`.
- Current status **MUST** be `IDLE`.
- Records `t1_round = current_round` and sets `status = ARMED`.

#### `confirm(owner)`

- Sender **MUST** be `M_exec`.
- Current status **MUST** be `ARMED`.
- Current round **MUST** be ≥ `t1_round + min_delay`.
- Sets `status = READY`.

#### `cancel(owner)`

- Sender **MUST** be `owner` or `M_exec`.
- If status is `EXECUTED`, the call **MUST** fail.
- Resets `status = IDLE`, zeroes `t1_round`, preserves `H_lsig` unless cleared explicitly.

#### `bequeath(owner, preimage)`

- Sender **MUST** be `M_exec` (or a relayer whose account is authorized by `M_exec`).
- Must be executed in a two-transaction atomic group:
  - `gtx[0]`: this AppCall.
  - `gtx[1]`: transaction from `A_owner` with `RekeyTo = A_heir`, signed by delegated LSig.
- Preconditions:
  - `status == READY`.
  - If `expiry_round > 0`, `current_round ≤ expiry_round`.
  - `keccak256(preimage) == H_lsig`.
- Effects:
  - Sets `status = EXECUTED` and records `execution_round`.
  - Optionally clears stored blob or rotates executor if signalled.
- Idempotence: further `bequeath` calls **MUST** fail once executed.

#### Optional Helpers

- `rotate_executor(owner, new_msig)` — Sender **MUST** be `owner`, allowed only when `status == IDLE`, sets `executor = new_msig`.
- `store_blob(owner, encrypted_blob)` — Sender **MUST** be `owner` (initial load) or `M_exec` (archival); stores encrypted LogicSig blob after verifying `keccak256(blob_contents) == H_lsig`.

### Delegated LSig Program

The delegated LogicSig **MUST** enforce the following TEAL constraints (example pseudocode, version 11):

```
#pragma version 11
global GroupSize
int 2
==
txn GroupIndex
int 1
==
&&
gtxn 0 TypeEnum
int appl
==
&&
gtxn 0 ApplicationID
int 123456789
==
&&
// ABI selector "bequeath"
gtxn 0 ApplicationArgs 0
byte "bequeath"
==
&&
txn RekeyTo
addr VKDAH6ECLG2MZ4H5IFH5OQ5ESAFI6KM3VL7Q6XG5R2KEDA7D2L5OFGM3GE
==
&&
txn Fee
global MinTxnFee
<=
&&
txn CloseRemainderTo
global ZeroAddress
==
&&
txn AssetCloseTo
global ZeroAddress
==
&&
int 1
return
```

If expiry is desired, the program **SHOULD** add a `txn LastValid` or `gtxn 0 ApplicationArgs[1]` comparison. The LogicSig signature **MUST** be produced by `A_owner` and stored offline until needed.

### Group Transaction Requirements

- `gtx[0]`: AppCall `bequeath`, sender `M_exec`, includes boxes/accounts for `owner` and `heir`, pays fees for the group.
- `gtx[1]`: Payment (0 algo) or KeyReg from `A_owner`, `RekeyTo = A_heir`, signed by delegated LSig, fee ≤ MinTxnFee, no close-to fields set.
- The group **MUST** execute atomically; any failure reverts both transactions.

### Validation Summary

- `Txn.sender()` checks enforce that only the intended parties call each method.
- Box/local state ownership **MUST** be validated to avoid collisions.
- Duplicate `set_will` calls **SHOULD** overwrite existing data but leave `status = IDLE`.
- Status preconditions **MUST** guard each method to preserve the lifecycle.

## Rationale

The double-action executor model (arm then confirm) provides a human-check delay, ensuring accidental or malicious triggers can be cancelled by the owner. Binding the delegated LSig via `H_lsig` prevents replay in different contexts and ensures that any tampering with the stored blob is detected. Storing only hashes on-chain keeps sensitive signatures offline, while optional encrypted blob storage supports custodial services. The design reuses existing protocol primitives (stateful app, LogicSig rekey) without demanding consensus changes, enabling broad compatibility.

## Backwards Compatibility

This ARC adds an optional application pattern and does not modify protocol rules. Existing accounts remain unaffected unless they deploy the AppWill. Therefore, there are no backwards-compatibility concerns.

## Test Cases

Reference implementations **SHOULD** provide tests that cover:

- Full happy path: `set_will → arm → confirm → bequeath` resulting in `A_owner` rekeyed to `A_heir`.
- Rejection when `confirm` occurs before `min_delay` rounds elapse.
- Rejection of `bequeath` for invalid preimage, incorrect group composition, or missing executor signature.
- Cancellation from each state (`IDLE`, `ARMED`, `READY`).
- Expiry scenario where `READY` lapses and returns to `IDLE`.
- Encrypted blob integrity checks.

## Reference Implementation

A reference implementation **MAY** be provided using PyTeal or AlgoKit. Suggested artifacts:

- PyTeal contract implementing the AppWill lifecycle and box storage.
- Offline tooling to construct the delegated LSig, compute `H_lsig`, and assemble the execution group.
- Integration tests demonstrating the lifecycle with mocked executors and heirs.

## Security Considerations

- **Replay Attacks**: Mitigated by `H_lsig` binding (program, signature, heir, executor, App ID, salt) and the LogicSig’s strict group checks.
- **Front-Running**: Atomic groups prevent third parties from inserting competing transactions; executors should monitor mempool to ensure inclusion.
- **LSig Exposure**: Storing only the hash on-chain prevents leakage; encrypted blobs (on- or off-chain) and secure key custody are RECOMMENDED.
- **Delay & Expiry**: `min_delay` grants time for dispute detection; optional `expiry_round` limits executor control window.
- **Owner Cancellation**: `cancel` enables the owner (if still active) to revert to `IDLE` instantly, blocking execution.
- **Fee and Close Controls**: LSig enforces minimum fee and prohibits close-to fields, preventing fund drains.
- **Executor Integrity**: The LogicSig and app validate the multisig address only, avoiding dependencies on its internal composition while allowing optional rotation in `IDLE`.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
