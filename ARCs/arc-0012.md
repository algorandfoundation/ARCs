---
arc: 12 
title: Algorand Naming Service  
status: Draft
---

# Algorand Naming Service 

> This API is a draft.
> Some elements may change. In particular, the error part may change drastically depending on feedback.

## Summary

A specification for a service to store and resolve arbitrary properties for a name.

## Abstract

The goal of this API is to propose a standard way for names to be associated with a set of properties and for those propperties to be resolved given the name. It provides recommendations 
for the smart contracts to facilitate storage as well as wallets or dapps to resolve the properties. 
 
## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).

> Comments like this are non-normative.

An ARC-xxx Naming Service is embodied as two Smart Contracts and one Service:

#### Smart Contracts

1. A Stateful Smart contract (referred to as Name Service) that stores the owner of the name and properties for that name and validates the logic for attempted opt-ins
2. A template Stateless smart contract (referred to as Name Record) that has only the name as the template variable and includes the App ID of the App the name is relevant for. 

#### Service

1. A service that provides the functionality to resolve a name to a property or set of properties. This may be a library that implements the functionality necessary to perform resolution or a we service.

### Names

Names are period separated strings. The right most element is the `domain` under which the next element can be resolved. 

Resolution of a name starts with a known `root` Name Service App ID and resolution proceeds from right to left until the field or fields are fully resolved.

Up to 16 properties MAY be associated with a name, where one MUST be the owner.

A Name MAY refer to a single property in the Local State of of the Name Record or omit the property name and the full local state is returned as properties. 

```
silvio.algo  =>  {"address":Global.ZeroAddress(), "twitter":"@silviomicali", "l337":"asf"}
twitter.silvio.algo => "@silviomicali"
```

### Properties

A Property is a key/value pair stored in the local state of the Name Record.

The key of a property MUST be a byte string
The length in bytes of a property key/value pair MUST be <= 128 bytes.


### Name Service

A Name Service is a stateful smart contract that provides the functionality for a validated Name Record to opt-in/out and store arbitrary properties. 

- A Name Service MUST validate the Registration by performing (Template Contract Validation)[#Template_Contract_Validation]
- A Name Service MUST Set the `owner` property to the owner value provided in the Registration Transaction.  If one is not provided, the Opt-In must fail.
- A Name Service MUST allow the Name Record to Unregister if the transaction is co-signed by the `owner` (Either grouped atomicly or with a valid signature from the owner?) 


### Name Record

A Name Record is a template contract that is valid for only one Name Service. 

- A Name Record MUST include the App ID of the `domain` it should be resolved under. 
- A Name Record MUST NOT allow any action besides Opting-in/Out of the Application


### Name Resolution

To resolve a name:

1. The name is split by periods into a list of names (eg silvio.algo => [silvio, algo])
2. The last element is the root and must be associated to a known App ID ahead of time (eg algo => app id 42)
3. The template contract for that App is retrieved (TODO: how?) and next element is populated into the contract
4. The bytecode is then hashed into an address ( address = sha512_256("Program"+bytecode) )
5. The local state for the address is retrieved for the App ID
5. (Optional) If the name contains more components:
	a) If the next component is a property in the local state, it is the value being resolved and is returned to the requestor 
	b) Else the special property `AppID` in the local state is used to repeat steps 2=>5 until the name is fully resolved

A Name Resolution service MAY cache the App IDs for a given domain.


### Name Registration

To register a Name Record:

1. The Template Variable for the domain is retrieved and the name is populated and compiled.
2. The Resultant programs address is seeded with enough Algos to cover opt-ins
3. An Application Opt-In Transaction is generated with the ApplicationArgs set to [populated contract bytecode, $properties] and is submitted to the network.

### Property Updates

Properties in the local state for a given Name Record MAY be updated. 

The updates MUST take the form of an Application Call Transaction where:
1. The Accounts array MUST contain the address of the name being updated
2. The `from` field matches the `owner` field of the local state for the Name Record being updated
3. The AppArgs contains the keys/values for the properties being updated ([key1,value1,key2,value2,...])


### Ownership Transfer 

To transfer a name, an application call transaction is submitted where:

1. The Accounts array MUST contain the address of the Name Record being transferred.
2. The `from` field matches the `owner` field of the local state for the Name Record transferred
3. The AppArgs contains the new owner address

The Application MUST update the owner field to the new owner.


### Template Validation

To validate a template contract the populated template contract is passed into the opt-in transaction as an AppArg and converted to a "Contract Blank" which is hashed compared to a pre-image.  The Address opting-in is also compared against the hash of the populated template contract that was passed. 

#### Setup:

1. The Name Record template contract with the App ID of it's parent domain and one Template Variable for the name is compiled with a dummy variable
2. The byte location of the Name variable is identified and removed from the bytecode to provide a "Contract Blank"
3. The "Contract Blank" bytes are hashed to provide a pre-image (sha256(bytecode)) 
4. The Location and Contract Blank Hash are added to the Name Service Approval Program.

#### Validation:

1. During Opt-In the populated Template Contract is passed as an AppArg
2. The location of the name determined during Setup is used to find and remove the Name being registered to produce the "Contract Blank". 
3. The "Contract Blank" bytes are hashed and compared to the pre-image from the Setup
4. The populated Template Contract is hashed to produce an address and compared to the `from` address of the account Opting-in
5. If all checks pass, the template is valid and can proceed to opt-in and set properties


