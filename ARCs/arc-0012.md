---
arc: 12 
title: Algorand Naming Service  
status: Draft
---

# Algorand Naming Service 

> This API is a draft.
> Some elements may change. In particular, the error part may change drastically depending on feedback.

## Summary

A specification for a service to store and resolve arbitrary properties for a name.

## Abstract

The goal of this API is to propose a standard way for names to be associated with a set of properties and for those propperties to be resolved given the name. It provides recommendations for the smart contracts to facilitate storage as well as wallets or dapps to resolve the properties. 
 

## Definitions:

*Name* - A byte string used to provide a convenient reference to a set of Properties (eg silvio.algo)

*Root* - The domain under which the Name is registered (eg .algo)

*Property* - A Key/Value pair stored in Local State of a Name Record (eg "twitter": "@silviomicali" )

*Name Record* - A Contract Account with the Template Variable for the Name populated and Opted-In to a Name Registry 

*Name Registry* - A Stateful Smart Contract that allows Name Records to opt-in and maintains Properties associated in their Local State

*Owner* - The Account that has authority to update Properties for a Name Record

*Name Resolution* -  The method by which Properties for Names are found 

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).

> Comments like this are non-normative.



An ARC-xxx Naming Service is embodied as two Smart Contracts to store Names and Properties and a method to Resolve the names:

#### Smart Contracts

A Stateless SC (Name Record) is used as a contract account. The logic is a Template with one Template Variable, the Name. This provides a predictable address to use for resolution and can opt-in to the Name Registry.  Local State for the address is used to store arbitrary Properties that may be resolved at the name.  

A Stateful SC (Name Registry) validates the Name Record contract and allows storage of Properties assocaited with a Name to be stored in its local state.

#### Resolver

A resolver is any service that provides the functionality to resolve a name to a property or set of properties. This may be a library that implements the functionality necessary to perform resolution or a we service.

### Names

Names are resolved from right to left. The right most element is the `root` under which the next element to the left can be resolved. 

Resolution of a name starts with a known `root` Name Registry App ID and resolution proceeds from right to left until the field or fields are fully resolved.

Up to 16 properties MAY be associated with a name, where one MUST be the owner.

A Name MAY refer to a single property in the Local State of of the Name Record or omit the property name and the full local state is returned as properties. 

```
silvio.algo  =>  {"address":Global.ZeroAddress(), "twitter":"@silviomicali", "l337":"asf"}
twitter.silvio.algo => "@silviomicali"
```

### Properties

The key of a property MUST be a byte string
The length in bytes of a property key/value pair MUST be <= 128 bytes.


### Name Registry 

- A Name Registry MUST validate the Registration by performing [Template Contract Validation](#template-contract-validation)
- A Name Registry MUST Set the `owner` property to the owner value provided in the Registration Transaction.  If one is not provided, the Opt-In must fail.
- A Name Registry MUST allow the Name Record to Unregister if the transaction is co-signed by the `owner` (Either grouped atomicly or with a valid signature from the owner?) 


### Name Record

- A Name Record MUST include the App ID of the `root` it should be resolved under. 
- A Name Record MUST NOT allow any action besides Opting-in/Out of the Application


### Name Register

> Note: Before registering, the Name Record's contract account needs to be seeded with enough Algos to cover opt-in

To register a Name Record an Application OptIn transaction is submitted where:

1. The ApplicationArgs array is populated with the Name Record bytecode and properties ([bytecode, key1, value1, key2, value2 ,...])
2. The Account array is populated with the Name Record Account annd the registering Owner

### Name Deregister

Name Records MAY be deregistered to clear their state.

To deregister a Name Record an atomic group containing two transactions:
1. A 0 amt pay txn signed by the owner validate the Owners authority 
2. An Application Clear Transaction to remove the local state of the Name Record

### Property Set 

Properties in the local state for a given Name Record MAY be updated. 

The updates MUST take the form of an Application Call Transaction where:

1. The Accounts array MUST contain the address of the name being updated
2. The `from` field matches the `owner` field of the local state for the Name Record being updated
3. The AppArgs contains the keys/values for the properties being updated ([key1,value1,key2,value2,...])

### Property Delete

Properties in the local state for a Name Record MAY be deleted

The deletes MUST take the form of an Application Call Transaction where:

1. The Accounts array MUST contain the address of the name being updated
2. The `from` field matches the `owner` field of the local state for the Name Record being updated
3. The AppArgs contains the keys for the properties being deleted ([key1,key2,key2])

### Ownership Transfer 

To transfer a name, an application call transaction is submitted where:

1. The Accounts array MUST contain the address of the Name Record being transferred and The address of the new owner.
2. The `from` field matches the `owner` field of the local state for the Name Record transferred
3. The AppArgs contains the new owner address

The Application MUST update the owner field to the new owner.


## Name Resolution

To resolve a name

1. The Name is split by periods into a list of elements (eg silvio.algo => [silvio, algo])
2. The N-1 name is populated into its Name Record bytecode and hashed to find its an address (sha512_256("Program" + bytecode))
3. The App ID for the first Root is used to retrieve the local state for the address
4. (Optional) If the name contains more components:
	a) If the next element is a Property in the local state, return the value for that property
	b) Otherwise the special property `AppID` in the local state is used to repeat steps 2=>4 until the name is fully resolved

> The App ID of the right most element and must be associated to a known App ID ahead of time (eg algo => app id 42)
> Each element in the Name is the root for the element preceeding.

A Name Resolution service MAY cache the App IDs for a Roots.


## Template Contract Validation

For the Name Registry to validate a Template Contract, it is passed the bytecode for the logic as an AppArg. The bytecode is manipulated to remove the bytes for the name creating a "Contract Blank". It is hashed and compared to the expected hash of a "Contract Blank". The original bytecode is hashed to generate the address and compared with the address of the account opting-in.

#### Setup:

1. The Name Record Template Contract and is compiled with a dummy variable
2. The byte location of the Name variable is noted and the bytes for the Name are removed, creating the "Contract Blank"
4. The "Contract Blank" bytes are hashed to provide a pre-image (sha256(bytecode)) 
5. The Name bytecode Location and hash("Contract Blank") are added to the Name Registry Approval Program (Hardcoded or global vars?).

#### Validation:

1. During Opt-In the Name Record bytecode is passed as an AppArg
2. The bytecode location of the Name is used to find and remove the bytes for the Name variable, producing the "Contract Blank". 
3. The "Contract Blank" bytes are hashed and compared to the hash("Contract Blank") from setup
4. The Name Record bytecode is hashed to produce an address and compared to the `from` address of the account Opting-in
5. If all checks pass, the template is valid and can proceed to opt-in and set properties
