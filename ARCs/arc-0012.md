---
arc: 12 
title: Algorand Naming Service  
status: Draft
---

# Algorand Naming Service 

> This API is a draft.
> Some elements may change. In particular, the error part may change drastically depending on feedback.

## Summary

A specification for a service to store and resolve arbitrary properties for a name.

## Abstract

The goal of this API is to propose a standard way for names to be associated with a set of properties and for those propperties to be resolved given the name. It provides recommendations for the smart contracts to facilitate storage as well as wallets or dapps to resolve the properties. 
 
## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).

> Comments like this are non-normative.

An ARC-xxx Naming Service is embodied as two Smart Contracts to store Names and Properties and a method to Resolve the names:

## Definitions:

*Name* - A byte string used to provide a convenient reference to a set of Properties
*Root* - The Domain under which the Name is registered
*Property* - A Key/Value pair stored in Local State of a Name Record
*Name Record* - A Contract Account with the Template Variable for the Name populated and Opted-In to a Name Registry 
*Name Registry* - A Stateful Smart Contract that allows Name Records to opt-in and maintains Properties associated in their Local State
*Owner* - The Account that has authority to update Properties for a Name Record

#### Smart Contracts

A Stateless SC (Name Record) is used as a contract account. The logic is a Template with one Template Variable, the Name. This provides a predictable address to use for resolution and can opt-in to the Name Registry.  Local State for the address is used to store arbitrary Properties that may be resolved at the name.  

A Stateful SC (Name Registry) validates the Name Record contract and allows storage of Properties assocaited with a Name to be stored in its local state.

#### Resolver

A resolver is any service that provides the functionality to resolve a name to a property or set of properties. This may be a library that implements the functionality necessary to perform resolution or a we service.

### Names

Names are period separated strings. They are resolved from right to left. The right most element is the `root` under which the next element to the left can be resolved. 

Resolution of a name starts with a known `root` Name Registry App ID and resolution proceeds from right to left until the field or fields are fully resolved.

Up to 16 properties MAY be associated with a name, where one MUST be the owner.

A Name MAY refer to a single property in the Local State of of the Name Record or omit the property name and the full local state is returned as properties. 

```
silvio.algo  =>  {"address":Global.ZeroAddress(), "twitter":"@silviomicali", "l337":"asf"}
twitter.silvio.algo => "@silviomicali"
```

### Properties

A Property is a key/value pair stored in the local state of the Name Record.

The key of a property MUST be a byte string
The length in bytes of a property key/value pair MUST be <= 128 bytes.


### Name Registry 

A Name Registry is a stateful smart contract that provides the functionality for a validated Name Record to opt-in/out and store arbitrary properties. 

- A Name Registry MUST validate the Registration by performing (Template Contract Validation)[#template-validation]
- A Name Registry MUST Set the `owner` property to the owner value provided in the Registration Transaction.  If one is not provided, the Opt-In must fail.
- A Name Registry MUST allow the Name Record to Unregister if the transaction is co-signed by the `owner` (Either grouped atomicly or with a valid signature from the owner?) 


### Name Record

A Name Record is a template contract that is valid for only one Name Registry. 

- A Name Record MUST include the App ID of the `root` it should be resolved under. 
- A Name Record MUST NOT allow any action besides Opting-in/Out of the Application


### Name Resolution

To resolve a name:

1. The name is split by periods into a list of names (eg silvio.algo => [silvio, algo])
2. The last element is the root and must be associated to a known App ID ahead of time (eg algo => app id 42)
3. The template contract for that App is retrieved from the Apps global state and next element is populated into the contract
4. The bytecode is then hashed into an address ( address = sha512_256("Program"+bytecode) )
5. The local state for the address is retrieved for the App ID from the Algod API
5. (Optional) If the name contains more components:
	a) If the next component is a property in the local state, it is the value being resolved and is returned to the requestor 
	b) Else the special property `AppID` in the local state is used to repeat steps 2=>5 until the name is fully resolved

A Name Resolution service MAY cache the App IDs for a given domain.


### Name Registration

To register a Name Record an Application OptIn transaction is created where:

1. The bytecode of the populated Template Contract representing the Name Record is passed as the first Application Argument 


3. The Template Contract for the Name Registry is retrieved and the name is populated with the name to register and compiled.
4. The Resultant programs address is seeded with enough Algos to cover opt-ins
5. An Application Opt-In Transaction is generated with the ApplicationArgs set to [populated contract bytecode, key1, value1, key2, value2 ,...] and is submitted to the network.



### Name Deregister

Name Records MAY be deregistered to clear their state.

To deregister a Name Record an atomic group containing two transactions is, one to validate the Owners authority and one Application Clear Transaction to remove the local state of the Name Record.



### Property Updates

Properties in the local state for a given Name Record MAY be updated. 

The updates MUST take the form of an Application Call Transaction where:

1. The Accounts array MUST contain the address of the name being updated
2. The `from` field matches the `owner` field of the local state for the Name Record being updated
3. The AppArgs contains the keys/values for the properties being updated ([key1,value1,key2,value2,...])

### Property Deletes

Properties in the local state for a Name Record MAY be deleted

The deletes MUST take the form of an Application Call Transaction where:

1. The Accounts array MUST contain the address of the name being updated
2. The `from` field matches the `owner` field of the local state for the Name Record being updated
3. The AppArgs contains the keys for the properties being deleted ([key1,key2,key2])

### Ownership Transfer 

To transfer a name, an application call transaction is submitted where:

1. The Accounts array MUST contain the address of the Name Record being transferred and The address of the new owner.
2. The `from` field matches the `owner` field of the local state for the Name Record transferred
3. The AppArgs contains the new owner address

The Application MUST update the owner field to the new owner.


### Template Validation

For the Name Registry to validate a Template Contract, it is passed the bytecode for the logic as an AppArg. The bytecode is manipulated to remove the bytes for the name creating a "Contract Blank". It is hashed and compared to the expected hash of a "Contract Blank". The original bytecode is hashed to generate the address and compared with the address of the account opting-in.

#### Setup:

1. The Name Record Template Contract and is compiled with a dummy variable
2. The byte location of the Name variable is noted and the bytes for the Name are removed, creating the "Contract Blank"
4. The "Contract Blank" bytes are hashed to provide a pre-image (sha256(bytecode)) 
5. The Name bytecode Location and hash("Contract Blank") are added to the Name Registry Approval Program (Hardcoded or global vars?).

#### Validation:

1. During Opt-In the Name Record bytecode is passed as an AppArg
2. The bytecode location of the Name is used to find and remove the bytes for the Name variable, producing the "Contract Blank". 
3. The "Contract Blank" bytes are hashed and compared to the hash("Contract Blank") from setup
4. The Name Record bytecode is hashed to produce an address and compared to the `from` address of the account Opting-in
5. If all checks pass, the template is valid and can proceed to opt-in and set properties
