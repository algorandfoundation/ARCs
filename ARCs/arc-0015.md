---
arc: 15
title: Algorand Standard for Encrypted Short Messages 
status: Draft
---

# Algorand Standard for Encrypted Short Messages 

> This standard is a draft.
> Some elements may change.

## Summary

A standard scheme for note field encryption/decryption that allows for private messages (aka SMS) on Algorand Network.

## Abstract

Algorand public account addresses (Ed25519) can be converted to DH keys (Curve25519) suitable for encryption.  
A sender can use the converted public key of the recipient to encrypt message contents in the note field of a Payment Transaction. Assuming that message authenticity is assured by transaction signature verification, the NACL PKI encryption can be used without authentication and the need for the sender's private key. The recipient can decrypt the message successfully with a derivative of his Algorand account's private key. 

A minimum transaction amount and other fees are proposed to reduce the number of 'spam' messages and incentivise wallet apps to incorporate this standard. 

## Specification

### Extensible message format

The payload of the transaction's note field is defined as UINT8Array MessagePack encoding of an **ALGOSMSV0_NOTE** object. 

The **ALGOSMSV0_NOTE** object contains, among other fields, an encrypted UINT8Array MessagePack encoding of **ALGOSMSV0_MESSAGE**.

#### Definitions

**ALGOSMSV0_TYPE_NOTE**: `algosms/v0:note`

**ALGOSMSV0_TYPE_MSG**: `algosms/v0:msg`

```ts
// UINT8Array ecrypted note contents as msgpack encoded object
interface ALGOSMSV0_NOTE {
	/** Object type eq to ALGOSMSV0_TYPE_NOTE **/
	_t: string ;

	/** one-time public key of the NACL's sealed box **/
  otPK: Uint8Array;

	/** cipherText of the ALGOSMSV0_MESSAGE structure **/
  cT: Uint8Array;
}
```

```ts
// UINT8Array ALGOSMSV0_MESSAGE contents as msgpack encoded object
interface ALGOSMSV0_MESSAGE {
	/** Object Type - eq to ALGOSMSV0_TYPE_MSG **/
	_t: string,

	/** Mandatory fields **/

	/** Short visible message contents in UTF-8 **/
	msg: string,

	/** Optional fields **/

	/** Optional display name chosen by the sender, to be displayed along reverse Unstoppable/NF.domains **/
	from?: string,

	/** Optional reference (e.g. threadID, invoiceID, txnID) **/
	ref?: string
	
	/** Optional URI (URL/URN/...) **/
	uri?: string,

	/** Optional JSON-encoded metadata **/
	meta?: string,

	/** Optional binary content **/
  bin?: Uint8Array,

	/** Optional random padding to hide original message length. **/
	pad?: Uint8Array,

}
```

### Message encryption (seal)

1. A message object of type ALGOSMSV0_MESSAGE is converted to MessagePack UINT8Array using algosdk.encodeObj implementation (**encMsg**)
2. Recipient public DH key is derived from destination account's public key (**rcptPubKey**)
3. A static nonce is derived from the first 24 bytes of the sender address public key. (**nonce**)
4. An ephemeral DH key pair is generated (**otSecretKey**, **otPubKey**)
5. Encryption is done using `nacl.box(encMsg, nonce, rcptPubKey, otSecretKey)` library call.
6. A **notePayload** of type ALGOSMSV0_NOTE is constructed as from resulting ciphertext (**cT**) , as well as **otPubKey** 
7. The final binary note contentents are result of algosdk.encodeObj(**notePayload**)

### Note decryption (unseal)
1.  A binary note in UINT8Array form is decoded to ALGOSMSV0_NOTE object (**)
2.  A static nonce is derived from the first 24 bytes of the sender address public key. (**nonce**)
3.  An one-time encryption public key is copied from the first 32 bytes of cipherBufferWithOTPubKey (**otPublicKey**)
4.  A cipher buffer is copied from the rest of the payload (**cipherBuffer**)
5.  A recipient secret crypto key is derived from the private key of his Algorand account (**rcptSecretKey**)
6. Message is decrypted by a call to `nacl.box.open(cipherBuffer, nonce, otPublicKey, rcptSecretKey)`
7. Message is decoded into the final JSON string with an UTF-8 decoder 


### Sample input message and note

Input message: 
```ts
{
	_t:   "algosms/v0:msg",
	msg:  "A new standard definition is waiting for your comment.",
	from: "ChainSMS ARCs department",
	uri:  "chainsms.xyz/arcs",
	meta: JSON.stringify({Algorand:"rocks!"}),
	pad:  int8Array(5) [ 175, 154, 177, 151, 232 ],
	ref:  "ARC-0015"
} 	
```
Output Transaction:
[O5TFQPZGOMVO3KEYW3UIGFE7GTG3WMTT5BP4Z53EBQ6IQUBDG4XQ](https://goalseeker.purestake.io/algorand/testnet/transaction/O5TFQPZGOMVO3KEYW3UIGFE7GTG3WMTT5BP4Z53EBQ6IQUBDG4XQ)

Output Note (MessagePacked): 
```json
{"_t":"algosms/v0:note","cT":{"type":"Buffer","data":[108,2,6,160,186,107,247,188,14,60,102,222,154,77,164,191,200,139,250,35,194,232,231,164,106,149,32,5,72,88,212,117,98,97,246,75,100,240,67,242,224,139,3,197,142,215,212,85,226,172,70,113,25,108,26,81,184,132,61,148,91,155,121,164,66,147,246,208,133,132,2,212,183,216,154,51,219,6,207,139,89,139,207,140,150,166,173,118,178,166,218,95,133,126,181,132,200,173,235,90,241,13,84,156,62,223,189,104,125,223,40,219,124,73,216,176,37,122,206,0,150,254,209,93,178,86,241,200,53,252,13,38,150,244,58,125,29,175,46,20,244,96,253,6,166,69,207,101,28,221,210,179,211,188,166,203,57,237,230,52,228,139,145,5,185,209,172,238,98,133,240,96,37,108,197,25,52,68,4,247,74,84,27,58,240,8,147,22,112,69,221,104,24,210,198,78,141,22]},"otPK":{"type":"Buffer","data":[90,112,144,78,22,13,121,240,201,96,29,71,226,41,168,93,190,184,99,174,191,16,33,68,130,60,213,151,246,34,255,123]}}
```

### Application behaviour
* Production message sending **must** be done on the *main-net*.
 * Application **should** pad the message with enough random characters to ensure that message content cannot be deduced by examining the length of the encrypted note.
 * A note **should not**  be decrypted automatically by a Wallet if the amount of *Algo* sent in a transaction is less than ten (10) times the minimum transaction fee at the time of transaction date. 
* A decryption fee **may** be collected by a Wallet for each decryption operation. 

### Security

* Message authenticity is assured by Algorand's L1
* The encryption scheme is a verbose version of NACL's sealed box.
	* A random, one-time, key pair is used for message encryption instead of sender's private key
	* Private keys of receiving party are only used to decrypt the message
* Amout of ciphertext padding is not mandated by this ARC

### Example TypeScript implementation
https://github.com/urtho/algosms-sdk

```ts
const ALGOSMSV0_TYPE_MSG:string = 'algosms/v0:msg';
const ALGOSMSV0_TYPE_NOTE:string = 'algosms/v0:note';

/**
 * sealMessageIntoNote takes a message object, an Algorand addresses of message recipient and sender and returns PKI encrypted message.
 * Encrypted message is an UINT8Array as retured from algosdk.encodeObject() and should be used directly as transaction's note field.
 * 
 * @param message - a ALGOSMSV0_MESSAGE object with a message and other metadata
 * @param recipientAlgoAddress - an Algorand address of recipient
 * @param senderAlgoAddress - an Algorand address of sender
 * @returns encypted message object in the form of MsgPack encoded UINT8Array
 */
function sealMessageIntoNote (
	message: ALGOSMSV0_MESSAGE,
	recipientAlgoAddress: string,
	senderAlgoAddress: string): Uint8Array 
{
  //Enforce object type
  if (!message || !message._t || message._t !== ALGOSMSV0_TYPE_MSG) {
    throw new Error("Unsupported message schema");
  }

  //Add a random length pad of up to 16 bytes if one is missing
  if (!message.pad || message.pad.length === 0) {
    message.pad = nacl.randomBytes(Math.floor(Math.random() * 16));
  }

  //Encode message with algosdk's MessagePack
  const encMsg = algosdk.encodeObj(message);

  //Let's use signing keys for encryption. :)
  const recipientPublicSignKey = algosdk.decodeAddress(recipientAlgoAddress).publicKey;

  //Convert recipient's public signing key to crypto key
  const rcptPubKey = ed2curve.convertPublicKey(recipientPublicSignKey);

  // We should not use our static private signing key for encryption. 
  // Also no need to prove I am the sender - it's done elsewhere. 
  // Let's use random KP and send the public part over the wire  
  const otKeyPair = nacl.box.keyPair();

  //Let's agree on static nonce as we have ephemeral keys anyway  
  const nonce = algosdk.decodeAddress(senderAlgoAddress).publicKey.subarray(0, nacl.box.nonceLength);

  // We are doing a verbose version of a sealed box here :D
  const cipherText = nacl.box(encMsg, nonce, rcptPubKey!, otKeyPair.secretKey);

  const notePayload: ALGOSMSV0_NOTE = {
    _t: ALGOSMSV0_TYPE_NOTE,
    otPK: otKeyPair.publicKey,
    cT: cipherText
  }

  //Encode note with algosdk's MessagePack
  const msgPackPayload = algosdk.encodeObj(notePayload);

  //TODO: check real max length
  if (msgPackPayload.length > 1000) {
    throw new Error("Encoded note lenght exceeds 1000 bytes");
  }

  return  msgPackPayload;
}


/**
 * unsealMessageFromNote takes a binary note, an Algorand addresses of message sender and full recipier Account and returns decrypted message.
 * Dectypted message is ALGOSMSV0_MESSAGE object.
 * 
 * @param note - a binary (not base64 encoded) transaction's note field to be decrypted
 * @param senderAlgoAddress - an Algorand address of sender
 * @param recipientAlgoAccount - an Algorand account (address and secret key) of recipient
 * @returns decrypted message and metadata as ALGOSMSV0_MESSAGE object.
 */
function unsealMessageFromNote (
		note: Uint8Array,
		senderAlgoAddress: string,
		recipientAlgoAccount: algosdk.Account):ALGOSMSV0_MESSAGE 
{
  const nonce = algosdk.decodeAddress(senderAlgoAddress).publicKey.subarray(0, nacl.box.nonceLength);
  const notePayload = algosdk.decodeObj(note) as ALGOSMSV0_NOTE;

  if (!notePayload || !notePayload._t || notePayload._t !== ALGOSMSV0_TYPE_NOTE) {
    throw new Error("Unknown encrypted payload schema");
  }

  //Convert recipient's private signing key into a cipher key
  const rcptSecretKey = ed2curve.convertSecretKey(recipientAlgoAccount.sk);

  //Unseal the box 
  const decryptedBuffer = nacl.box.open(notePayload.cT, nonce, notePayload.otPK, rcptSecretKey);

  //Check if decryption is OK
  if (!decryptedBuffer || decryptedBuffer.length === 0 ) {
    throw new Error("ciphertext is invalid or does not match recipient's secret key");
  }
  
  //Decode MsgPacked structure into ALGOSMS format;
  const message = algosdk.decodeObj(decryptedBuffer) as any;
  if (!message || !message._t) {    
    throw new Error("Unknown message schema");
  }

  switch (message._t) {
    case ALGOSMSV0_TYPE_MSG:
      return message as ALGOSMSV0_MESSAGE;
  }

  throw new Error("Unsupported message schema version");

}
```

## Rationale

Algorand blockchain unlocks many new use cases - anonymous user login to dApps and classical WEB2.0 solutions being one of them. For many use-cases, anonymous users still require asynchronous event notifications, and email seems to be the only standard option at the time of the creation of this ARC. With wallet adoption of this standard, users will enjoy real-time encrypted A2P (application-to-person) notifications without having to provide their email addresses and without any vendor lock-in. 

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).