---
arc: 15
title: Algorand Standard for Encrypted Short Messages 
status: Draft
---

# Algorand Standard for Encrypted Short Messages 

> This standard is a draft.
> Some elements may change.

## Summary

A standard scheme for note field encryption/decryption that allows for private messages (aka SMS) on Algorand Network.

## Abstract

Algorand public account addresses (Ed25519) can be converted to DH keys (Curve25519) suitable for encryption.  
A sender can use the converted public key of the recipient to encrypt message contents in the note field of a Payment Transaction. Assuming that message authenticity is assured by transaction signature verification, the NACL PKI encryption can be used without authentication and the need for the sender's private key. The recipient can decrypt the message successfully with a derivative of his Algorand account's private key. 

A minimum transaction amount and other fees are proposed to reduce the number of 'spam' messages and incentivise wallet apps to incorporate this standard. 

## Specification

### Extensible message format

The payload of the transaction's note field is defined as a concatenation of standard prefix, and base64 encoded binary blob includes a random public key, used during encryption, followed by `x25519-xsalsa20-poly1305` encrypted JSON object. 

**Prefix**: `algosms/v0:ej`
**Payload**: `base64(ephemeral_public_key+encrypted_payload)`

JSON object containing the message is defined as:
```ts
interface AlgoSMSv0 {
	/** Short message contents **/
	msg: string,

	/** Random padding/nonce to hide original message length. **/
	pad: string,

	/** Optional display name chosen by the sender **/
	from?: string,

	/** Optional reference (e.g. threadID, invoiceID, txnID) **/
	ref?: string
}
```

### JSON object encryption 

1. Message object is converted to JSON string and encoded to UINT8 array with an nUTF-8 encoder (**encMsg**)
2. Recipient public DH key is derived from destination account's public key (**rcptPubKey**)
3. A static nonce is derived from the first 24 bytes of the sender address public key. (**nonce**)
4. An ephemeral DH key pair is generated (**otSecretKey**, **otPubKey**)
5. Encryption is done using `nacl.box(encMsg, nonce, rcptPubKey, otSecretKey)` library call.
6. Resulting ciphertext is prepended with 32bytes of the **otPubKey** .
7. The concatenated result is used in base64 form as the **Payload**.

```ts
function encryptFor(
	message:string,
	recipientAlgoAddress:string,
	senderAlgoAddress: string
):string {
  const enc = new TextEncoder();
  const encMsg = enc.encode(message);
  
  //Let's use signing keys for encryption. :)
  const recipientPublicSignKey = algosdk.decodeAddress(recipientAlgoAddress).publicKey;
  
  //The message contains nonce/padding so let us use known nonce here and not send it over the wire. 
  const nonce = algosdk.decodeAddress(senderAlgoAddress).publicKey.subarray(0, nacl.box.nonceLength); 

  //Convert signing key to crypto key
  const rcptPubKey = ed2curve.convertPublicKey(recipientPublicSignKey);

  // We should not use our static private signing key for encryption. 
  // Also no need to prove I am the sender - it's done elsewhere
  // Let's use random KP and send the public part over the wire
  const otKeyPair = nacl.box.keyPair();
  const otSecretKey = otKeyPair.secretKey;
  const cipherBuffer = nacl.box(encMsg, nonce, rcptPubKey!, otSecretKey );
  const cipherBufferWithOTPubKey = 
	  Buffer.from(new Uint8Array([...otKeyPair.publicKey , ...cipherBuffer]));
  
  return cipherBufferWithOTPubKey.toString('base64');
}
```

### JSON object decryption
1.  An UINT8 buffer is decoded from base64 payload (**cipherBufferWithOTPubKey**)
2.  A static nonce is derived from the first 24 bytes of the sender address public key. (**nonce**)
3.  An one-time ecryption public key is copied from the first 32 bytes of cipherBufferWithOTPubKey (**otPublicKey**)
4.  A cipher buffer is copied from the rest of the payload (**cipherBuffer**)
5.  A recipient secret crypto key is derived from the private key of his Algorand account (**rcptSecretKey**)
6. Message is decrypted by a call to `nacl.box.open(cipherBuffer, nonce, otPublicKey, rcptSecretKey)`
7. Message is decoded into the final JSON string with an UTF-8 decoder 

```ts
function  decryptFrom (
	cipherB64:string, senderAlgoAddress:string, recipientAccount: algosdk.Account
):string {
	const  cipherBufferWithOTPubKey = Buffer.from(cipherB64,'base64');
	const  nonce = algosdk.decodeAddress(senderAlgoAddress).publicKey.subarray(0, nacl.box.nonceLength);
	const  otPublicKey = cipherBufferWithOTPubKey.subarray(0,nacl.box.publicKeyLength);
	const  cipherBuffer = cipherBufferWithOTPubKey.subarray(nacl.box.publicKeyLength);
	const  rcptSecretKey = ed2curve.convertSecretKey(recipientAccount.sk);
	const  decryptedBuffer = nacl.box.open(cipherBuffer, nonce, otPublicKey!, rcptSecretKey);
	const  dec = new TextDecoder();
	const  jsonMsg = dec.decode(decryptedBuffer);
	return  jsonMsg;
}
```

### Sample input message and note

Input JSON: 
```json
{
	"msg":"A new prescription is waiting for you in our portal.",
	"from":"MetaHealt Inc",
	"ref":"urologist@11/22/2021",
	"pad":"e700930d92933f07241d147577881044"
}
```
Output Note: 
`algosms/v0:ej5pdsxz1eE2aEkzumBkvyQv...[cut]...IjXavr7iKsWiBg==`

### Application behaviour
* Production message sending **must** be done on the *main-net*.
 * Application **must** pad the message with enough random characters to ensure that message content cannot be deduced by examining the length of the encrypted note.
 * A note **should not**  be decrypted automatically by a Wallet if the amount of *Algo* sent in a transaction is less than ten (10) times the minimum transaction fee at the time of transaction date. 
* A decryption fee **may** be collected by a Wallet for each decryption operation. 

### Security
[tbd] :)

### Example TypeScript implementation
https://github.com/urtho/algosms-sdk

## Rationale

Algorand blockchain unlocks many new use cases - anonymous user login to dApps and classical WEB2.0 solutions being one of them. For many use-cases, anonymous users still require asynchronous event notifications, and email seems to be the only standard option at the time of the creation of this ARC. With wallet adoption of this standard, users will enjoy real-time encrypted A2P (application-to-person) notifications without having to provide their email addresses and without any vendor lock-in. 

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).